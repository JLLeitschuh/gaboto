<?oxygen RNGSchema="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_all.rng" type="xml"?>
<!DOCTYPE Gaboto [
<!ENTITY oxp "http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#" >
<!ENTITY gabotoKML "http://ns.ox.ac.uk/namespace/gaboto/kml/2009/03/owl#" >
<!ENTITY dc "http://purl.org/dc/elements/1.1/" >
<!ENTITY v "http://nwalsh.com/rdf/vCard#" >
<!ENTITY geo "http://www.opengis.net/gml/" >
]>
<TEI xmlns="http://www.tei-c.org/ns/1.0"
     xmlns:xi="http://www.w3.org/2001/XInclude"
     rend="nosplit">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>Gaboto Library - User Manual</title>
        <author>Arno Mittelbach</author>
      </titleStmt>
      <publicationStmt>
        <date when="2009-02"/>
      </publicationStmt>
      <sourceDesc>
         <p>Born digital: no previous source exists.</p>
      </sourceDesc>
    </fileDesc>
      <revisionDesc>
          <change when="2009-02-26">
              <name>Arno Mittelbach</name>
          </change>
      </revisionDesc>
  </teiHeader>
  <text>
    <front>
        <div>
            <head>Preface</head>
            <p>
                The Gaboto Library - User Manual contains information and tutorials on how to use 
                the library and extend its functionality. Gaboto is using RDF and the named graph 
                extension to RDF as its underlying data model. The two main libraries that implement the RDF standard and 
                that Gaboto is built upon are:
                <list type="gloss">
                    <label>Jena</label>
                    <item>
                        Jena is an open source RDF triple store written entirely in Java. More information
                        on Jena can be found at its <ref target="http://jena.sourceforge.net/">website</ref>.
                    </item>
                    <label>NG4J</label>
                    <item>
                        NG4J is an extension for Jena implementing the concept of named graphs. More information
                        on NG4J can be found at its <ref target="http://www4.wiwiss.fu-berlin.de/bizer/ng4j/">website</ref>.
                    </item>
                </list>
                Besides the manual, I've tried to thoroughly document the source code in the JavaDoc format so that it
                can be used as a reference when working with the library. Looking at Jena's documentation will
                not be necessary for the first steps, but if you want to seriously use Gaboto you should at least
                work through the main tutorials.
            </p>
            <p>
                Have fun with Gaboto,<lb/>
                Arno Mittelbach
            </p>
        </div>
        <divGen type="toc"/>
    </front>
      <body>
        <div>
            <head>Introduction to Gaboto</head>

            <p>
                This chapter will give a brief introduction into the Gaboto system. I will explain the
                basic concepts and will give a short introduction to RDF, since understanding Gaboto's underlying
                data model is crucial for being able to properly work with it. I will start with describing
                the project, that led to the creation of Gaboto called <hi>OxPoints</hi> which I will use as
                a running example throughout this manual. Parts of the OxPoints data will also be shipped with
                Gaboto as an example project for you to be able to directly start playing with a completely
                configured system.
            </p>

            <div>
                <head>OxPoints - a short History</head>
                <p>
                    The old OxPoints system consisted of a large XML file mainly containing information about Colleges,
                    their main buildings and where these are located. Using XSL this information could be transformed
                    into various output formats such as JSON, HTML or KML. For example, the map of all colleges on the
                    university's main website was dynamically created by the OxPoints system. 
                </p>
                <p>
                    After more and more data was added and with the plan to add much more, it became clear that a system
                    based on one hierarchical XML file would not scale with the new requirements:
                    <list type="gloss">
                        <label>Time based data</label>
                        <item>
                            A time dimension should be introduced to be able to create historical maps.
                        </item>
                        
                        <label>Rich Relationships</label>
                        <item>
                            It should be able to express many different kind of relationships between entities in the
                            system.
                        </item>
                        
                        <label>More Entities</label>
                        <item>
                            Besides colleges and buildings many more entities should be added to the system (e.g. drain covers).
                        </item>
                        
                        <label>Extendable</label>
                        <item>
                            Since nobody could pin down where OxPoints was to be going it should be as easy as possible to
                            extend the system in any way imaginable.
                        </item>
                    </list>
                </p>
                <p>
                    If we only partly wanted to achieve these requirements we had to be very careful during the 
                    design of the underlying data model. We conducted research for several months and finally decided
                    to go with an RDF (a standard maintained by the W3C, meant to express relationships between entities)
                    based solution. We hope that chosing this very generic data model will address all the above requirements:
                    <list type="gloss">
                        <label>Time based data</label>
                        <item>
                            We have found a way to introduce a time dimension (see <ptr target="#chap_introduction_furtherReading"/> for
                            a description on the research).
                        </item>
                        
                        <label>Rich Relationships</label>
                        <item>
                            RDF is meant to express rich relationsships.
                        </item>
                        
                        <label>More Entities</label>
                        <item>
                            RDF has no restrictions on the elements it talks about. As long as you can make up
                            a URI for the element, you can use RDF to describe it.
                        </item>
                        
                        <label>Extendable</label>
                        <item>
                            RDF is very generic and meant to be extended. 
                        </item>
                    </list>
                </p>
                <p>
                    The platform choice fell on Java and Jena (an RDF triple store written in Java) since this
                    seemed to give us one of the most sophisticated open source triple stores and the flexibility
                    of Java.  
                </p>
            </div>
            <div>
                <head>RDF - a very brief introduction</head>
                <p>
                    To understand Gaboto you have to understand RDF. In this section I will only very briefly
                    describe RDF and its named graph extension. If any of this does not sound familiar, you should have
                    a look at the more detailed introductions in <ptr target="#chap_introduction_furtherReading"/>.
                </p>
                <p>
                    RDF describes the idea that any kind of resource can be identified by a URI and 
                    relationships between two resources can be described in the form of triples:
                    <eg>
                        subject    predicate    object .
                    </eg>
                    Subjects and predicates are always a resource, while objects can be either a resource
                    or a primitive literal (e.g. a string). To describe this manual we could, for example,
                    say:
                    <eg>
                        example:GabotoManual    dc:title     "Gaboto Library - User Manual" ;
                                                  dc:author    "Arno Mittelbach" .
                    </eg>
                    A set of these triples that belong together are called <hi>Graph</hi>.
                </p>
                <p>
                    The RDF specification assumes that all RDF triples in a system are stored in one Graph. An extension
                    to RDF called <hi>Named Graphs</hi> allows for the grouping of statements into various RDF Graphs, each
                    graph described by a URI. This makes it possible to describe a graph, like any other resource, with the
                    help of RDF.
                </p>
                <p>
                    We use this idea of describing graphs in RDF to introduce a time dimension to RDF. Each graph in Gaboto
                    contains statements that describe the state of resources during a given time span. So if, for example,
                    a college existed from 1500 to 1678 then we would put a triple describing the existance of the college
                    (we use the rdf:type predicate for this purpose) to the graph that contains all triples valid during
                    that particular time span:
                    <eg>
                        <![CDATA[
                            <http://graphURIs/1500-1678>
                               {
                                   oxpdata:someCollege    rdf:type    oxp:College .
                               }
                        ]]>
                    </eg>
                    To describe the graphs in the system and define the time span they cover we use a special
                    graph: the <hi>context description graph</hi>. To actually describe the time information
                    we are using the <ref target="http://www.w3.org/TR/owl-time/">time ontology</ref> proposed
                    by the W3C. We use another special graph, the <hi>global knowledge graph</hi> to store information
                    that is not time bound.
                </p>
            </div>
            <div>
                <head>So what exactly is Gaboto Library</head>
                <p>
                    Gaboto Library has nothing to do with Oxford University (except that it was developed there),
                    buildings, colleges or geo-data. It is a RDF storage engine, that allows for automatic mapping from
                    RDF to Java objects and is able to cope with time in RDF. It gives you RDF's flexibility of storing
                    objects, their properties and relationships between objects while mapping these structures to first
                    class java objects. This means that instead of handling abstractions of RDF triples in Java (which
                    is what Jena is providing) you handle objects like (in the case of OxPoints) Building, College
                    and can run operations.
                </p>
                <p>
                    With this Gaboto is <ref target="http://en.wikipedia.org/wiki/Object-relational_mapping">Object-relational mapping</ref>,
                    like <ref target="http://en.wikipedia.org/wiki/Hibernate_(Java)">Hibernate</ref> or 
                    <ref target="http://en.wikipedia.org/wiki/Propel_(PHP)">Propel</ref>. However, Gaboto is built upon
                    RDF instead of relational databases, which gives you a greater flexibility in defining relationships
                    and changing your datamodel.
                </p>
                <p>
                    The mapping rules are all configured in an XML configuration file (see <ptr target="#part_configuring"/>)
                    from which the necessary classes are automatically generated. So the basic steps in using Gaboto are:
                    <list type="ordered">
                        <item>Write configuration file, define objects, their properties and relationships.</item>
                        <item>Execute configuration script, that basically generates a jar file.</item>
                        <item>Plug in the jar file and start writing your system.</item>
                    </list>
                </p>
                <div>
                    <head>Gaboto versus Relational Database Approaches</head>
                    <p>
                        At this point you might ask: If I have to explicitely define my entities why shouldn't I go
                        for a relational database approach? The answer to this is simple: Although it is true that you
                        have to define the objects you are planning on using it is very easy to change these objects
                        and add new objects and relationships. It is a simple change in your configuration file and you
                        are set to go. On the other hand, trying to change the datamodel in a system based on a relational
                        database is usually a big hazard, resulting in altering and introducing new tables etc.
                    </p>
                </div>
            </div>
            <div xml:id="chap_introduction_furtherReading">
                <head>Further Reading</head>
                
                <list type="gloss">
                    <label><ref target="http://oxforderewhon.wordpress.com/">Erewhon Blog [http://oxforderewhon.wordpress.com/]</ref></label>
                    <item>
                        The project's blog provides various information about OxPoints and Gaboto. Especially the following articles
                        might be of interest:
                        <list type="gloss">
                            <label>
                                <ref target="http://oxforderewhon.wordpress.com/2008/11/18/Gaboto-providing-geodata-for-the-university-of-oxford/">
                                    OxPoints - Providing geodata for the University of Oxford
                                </ref>
                            </label>
                            <item>An introduction to OxPoints - Part 1</item>
                            
                            <label>
                                <ref target="http://oxforderewhon.wordpress.com/2008/11/22/Gaboto-and-the-semantic-web/">
                                    OxPoints and the Semantic Web
                                </ref>
                            </label>
                            <item>An introduction to OxPoints - Part 2</item>
                            
                            <label>
                                <ref target="http://oxforderewhon.wordpress.com/2008/11/26/rdf-an-introduction/">
                                    RDF - an Introduction
                                </ref>
                            </label>
                            <item>An introduction to RDF</item>
                            
                            <label>
                                <ref target="http://oxforderewhon.wordpress.com/2008/11/28/rdf-and-the-time-dimension-part-1/">
                                    RDF and the Time Dimension - Part 1
                                </ref>
                            </label>
                            <item>An article about RDF, focusing on the problem of using RDF to store dimensional data.</item>
                            
                            <label>
                                <ref target="http://oxforderewhon.wordpress.com/2008/12/10/rdf-and-the-time-dimension-part-2/">
                                    RDF and the Time Dimension - Part 2
                                </ref>
                            </label>
                            <item>
                                An article about RDF, focusing on the problem of using RDF to store dimensional data. The solution
                                (using named graphs) described here forms the basis of the Gaboto data model.
                            </item>
                            
                            <label>
                                <ref target="http://www.w3.org/RDF/">
                                    The RDF Specification [http://www.w3.org/RDF/]
                                </ref>
                            </label>
                            <item>
                                Provides several links and documents about the Resource Description Framework.
                            </item>
                        </list>
                    </item>
                    
                    <label><ref target="http://www.w3.org/TR/REC-rdf-syntax/">RDF Primer [http://www.w3.org/TR/REC-rdf-syntax/]</ref></label>
                    <item>
                        The RDF Primer provides a general introduction into the world of RDF.
                    </item>
                    <label><ref target="http://www.w3.org/2004/03/trix/">Named Graphs [http://www.w3.org/2004/03/trix/]</ref></label>
                    <item>
                        The website of a working group on named graphs.
                    </item>
                </list>
            </div>
        </div>
          
        <div>
            <head>Part I - Using Gaboto</head>    
            <p>
                Gaboto was developed to be used as the underlying datamodel for the new OxPoints system. As this provides
                us with a fully configured Gaboto system, I will explain Gaboto through the example of OxPoints.
            </p>
            <div>
                <head>Setting up a Test-Environment in Eclipse</head>
                <p>
                     In order to try out the presented examples without setting up a full Gaboto
                     system (which would include configuring the persistent storage, defining database connections
                     etc.) I will show you how to set up a simple environment with which you can try out
                     all the examples (and of course your own examples) presented in this manual.
                     While just using Gaboto, you are free to choose any development environment you feel comfortable
                     with. However, as Eclipse is my favorite development environment and we will need Eclipse
                     when we start looking into how Gaboto can be extended, I will present these instructions
                     for Eclipse.
                </p>
                
                <div>
                    <head>Install Eclipse</head>
                    <p>
                        If you do not yet have Eclipse installed, go to <ref target="http://www.eclipse.org/downloads/">http://www.eclipse.org/downloads/</ref>
                        and grab the latest copy (currently Ganymede 3.4.1). Eclipse comes in many different packages for various tasks but the standard
                        <hi>Eclipse IDE for Java Developers</hi> should be your package of choice. After downloading
                        the package, the installation usually just consists of unzipping the package. Check the instructions
                        for your OS for more information.
                    </p>
                </div>
                
                <div>
                    <head>Creating the Project</head>
                    <p>
                        Once you are in Eclipse, 
                        first get rid of the Welcome screen
                        and then switch to the Java Perspective 
                        (Window/Open Perspective/Java, if Java is not directly visible
                        go for Other and select Java from the following menu.). 
                        You can create
                        a new Java project by right clicking in the <hi>Package Explorer</hi> (panel on the left-hand side) and then
                        choosing new/Java Project. 
                        Type in a project name (e.g., Gaboto), 
                        make sure that you select Java 1.6 and click on Finish.
                    </p>
                </div>
                
                <div>
                    <head>Preparations for Running the Examples</head>
                    <p>
                        copy the folders lib and example-data (from the Gaboto.zip) into the directory (Gaboto) for your newly 
                        created project (i.e., just drag the files from the explorer/file browser into eclipse and drop them
                        onto your object). Copy the Gaboto.jar into the new lib folder under your project. 
                    </p>
                    <p>
                        To set the classpath you right-click your project
                        and select <hi>Properties</hi>. You go to
                        <hi>Java Build Path</hi>, then <hi>Libraries</hi> 
                        and click on <hi>Add JARs...</hi>. 
                        Select all the jars from the lib directory 
                        and use Open to add them to the classpath.
                        When you've added all the jars, click on OK.
                    </p>
                    <p>
                        We can now create a new package under the source folder (right-click on <hi>src</hi>, select New/Package).
                        Give it a name (e.g. example) and hit Finish. Create a new Class underneath it (right-click on the package and
                        select New/Class). Give it the name Test1 and click Finish.
                    </p>
                    <p>
                        Inside the curly brackets for the public class Test1, add the following two methods:
                        <eg>
                            <![CDATA[
 /**
	 * Main entrance Point
	 * 
	 * @param args
	 * @throws IOException 
	 * @throws SAXException 
	 * @throws ParserConfigurationException 
	 * @throws GabotoException 
	 */
	public static void main(String[] args) throws ParserConfigurationException, SAXException, IOException, GabotoException {
		// initialize Gaboto system
		GabotoLibrary.init(GabotoConfiguration.fromConfigFile());
		
		// load gaboto
		Gaboto gaboto = GabotoFactory.getEmptyInMemoryGaboto();
		
		File graphs = new File("graphs.rdf");
		FileInputStream fos = new FileInputStream(graphs);
		
		File cdg = new File("cdg.rdf");
		FileInputStream cdg_fos = new FileInputStream(cdg);
		
		gaboto.read(fos, cdg_fos);
		gaboto.recreateTimeDimensionIndex();
		
		processExample(gaboto);
	}

	/**
	 * Here we can test the examples.
	 * 
	 * @param gaboto
	 * @throws GabotoException
	 * @throws FileNotFoundException 
	 */
	private static void processExample(Gaboto gaboto) throws GabotoException, FileNotFoundException {
		// the example goes here
		System.out.println("Gaboto is up and running.");
	}
                            ]]>
                        </eg>
                    </p>
                    <p>
                        You will need to add some import statements. Eclipse will automatically add these, if you
                        use the QuickFixes (little light bulbs left of the code). Or you can use the autocompletion
                        (CTRL+Space): Go to the end of each term that is not recognized and click (CTRL+Space). If
                        you chose the same names as suggested, your final class should now look like:
                        
                        <eg>
                            <![CDATA[
package example;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

import javax.xml.parsers.ParserConfigurationException;

import org.oucs.gaboto.GabotoConfiguration;
import org.oucs.gaboto.GabotoLibrary;
import org.oucs.gaboto.entities.pool.GabotoEntityPool;
import org.oucs.gaboto.exceptions.GabotoException;
import org.oucs.gaboto.model.Gaboto;
import org.oucs.gaboto.model.GabotoFactory;
import org.oucs.gaboto.model.GabotoSnapshot;
import org.oucs.gaboto.timedim.TimeInstant;
import org.oucs.gaboto.transformation.json.GeoJSONPoolTransfomer;
import org.oucs.gaboto.vocabulary.OxPointsVocab;
import org.xml.sax.SAXException;



public class Test1 {

	/**
	 * Main entrance Point
	 * 
	 * @param args
	 * @throws IOException 
	 * @throws SAXException 
	 * @throws ParserConfigurationException 
	 * @throws GabotoException 
	 */
	public static void main(String[] args) throws ParserConfigurationException, SAXException, IOException, GabotoException {
		// initialize Gaboto system
		GabotoLibrary.init(GabotoConfiguration.fromConfigFile());
		
		// load gaboto
		Gaboto gaboto = GabotoFactory.getEmptyInMemoryGaboto();
		
		File graphs = new File("graphs.rdf");
		FileInputStream fos = new FileInputStream(graphs);
		
		File cdg = new File("cdg.rdf");
		FileInputStream cdg_fos = new FileInputStream(cdg);
		
		gaboto.read(fos, cdg_fos);
		gaboto.recreateTimeDimensionIndex();
		
		processExample(gaboto);
	}

	/**
	 * Here we can test the examples.
	 * 
	 * @param gaboto
	 * @throws GabotoException
	 * @throws FileNotFoundException 
	 */
	private static void processExample(Gaboto gaboto) throws GabotoException, FileNotFoundException {
		// the example goes here
		System.out.println("Gaboto is up and running.");
	}

}


                            ]]>
                        </eg>
                    </p>
                    <p>
                        Running the example (right-click on the class Test1 and choose Run As/Java Application) should result in
                        in printing <emph>Gaboto is up and running</emph> onto the console.<lb/>
                        Note: the Console pane has a Maximise button at the right end of its tool bar. You can now use the
                        method <hi>processExample</hi> to try out the examples.
                    </p>
                </div>
                <div>
                    <head>The Gaboto Object</head>
                    <p>
                        I will later tell you, that you should be careful ablut which Gaboto object you use for
                        what purpose. For trying out the examples you can simply use the created Gaboto object
                        (an in-memory object, that is not connected to any persistent storage).
                    </p>
                </div>
            </div>
            
            <div xml:id="chap_objectModel">
                <head>The Gaboto Object Model</head>
                <p>
                    This chapter describes the most important objects in the Gaboto object model and how to use them. I will not
                    describe objects in detail (that is describe all their methods and fields) but try
                    to concentrate on describing the relationship between objects and their purpose. For an
                    in depth description for each individual object please refer to the JavaDoc.
                </p>
                <div xml:id="chap_objectModel_Time">
                    <head>Time</head>
                    <p>
                        Although Gaboto does not force you to model time, it is one of its key features. Before we can start to describe
                        any of the "Gaboto classes" we have to get to know the two main classes that are used
                        througout Gaboto to work with time.
                    </p>
                    <note>
                        For more examples on the usage of TimeInstant and TimeSpan, have a look at the unit tests:
                        TestTimeSpan.java and TestTimeInstant.java in org.oucs.gaboto.test.classes.
                    </note>
                    <div>
                        <head>TimeInstant</head>
                        <p>
                            TimeInstant is used to describe a specific point in time. It is able to work with
                            a resolution upto days<note>The resolution might be refined in future versions.</note>, 
                            although, if uncertain, Gaboto is also able to handle time instants
                            that are not exactly specified. We need this functionality in order to be able to record
                            events that we knew took place in a certain year, but we neither know the month nor the day.
                        </p>
                        
                        <div>
                            <head>Examples</head>
                            <p>
                                Creating new time instants:
                                <eg>
                                    <![CDATA[
    TimeInstant ti1 = new TimeInstant(200,8,10);
    
    //September 12th, 567
    TimeInstant ti2 = new TimeInstant(567,8,11);
    
    // March 2nd, 200
    TimeInstant ti3 = new TimeInstant(200,2,1);
    
    // April, 200
    TimeInstant ti4 = new TimeInstant(200,3,null);
    
    // year 200
    TimeInstant ti5 = new TimeInstant(200,null,null);
                                    ]]>
                                </eg>
                            </p>
                            
                            <p>
                                Comparing time instants:
                                <eg>
                                    <![CDATA[
    int i = ti1.compareTo(ti2);
    System.out.println(i);
    // Result: This prints out -1, since t1 is earlier than t2.
    
    boolean eq = t4.equals(t5);
    System.out.println(eq ? "true" : "false");
    // Result: Prints out false. The two instants are not the same.
    
    boolean eq2 = t4.aboutTheSame(t5);
    System.out.println(eq2 ? "true" : "false");
    // Result: Prints out true. The two instants are roughly the same.
                                    ]]>
                                </eg>
                            </p>
                        </div>
                            
                    </div>
                    
                    <div>
                        <head>TimeSpan</head>
                        <p>
                            TimeSpan is used to describe a time span. Since <ref target="http://www.w3.org/TR/owl-time/">time-owl</ref>,
                            the ontology we use to describe the time dimension uses a start date and a duration to describe
                            a time span rather than a start date and an end date, TimeSpan follows the same concept. However,
                            it offers methods to convert one form to another, i.e. you can create a TimeSpan object from a
                            start and an end date or ask a TimeSpan object to return its start or end date.
                        </p>
                        <note>
                            Time spans can, as well as time instants be underspecified. However, if you do not specify
                            a month for its start date you may not specify a month for the duration.
                        </note>
                        <note>
                            Time spans do not have to have a defined end date. If a TimeSpan object is created without
                            any specification for its duration, Gaboto interprets the TimeSpan as being unbound.
                        </note>
    
                        <div>
                            <head>Examples</head>
                            <p>
                                Creating new time spans:
                                <eg>
                                <![CDATA[
    // begin: 100-04-11, lasts: 200 years, 6 months and 8 days.
    TimeSpan ts0 = new TimeSpan(100,3,10,200,6,8);
    
    // begin 1802, April, lasts: 200 years and 6 months
    TimeSpan ts1 = new TimeSpan(1802,3,null,200,6,null);
    
    // begin 1850-12-13, lasts: 100 years and 6 months
    TimeSpan ts2 = new TimeSpan(1850,11,12,100,6,0);
                                ]]>
                                </eg>
                                
                                Comparing time spans:
                                <eg>
                                    <![CDATA[
    System.out.println( ts0.equals(ts1) ? "true" : "false" );
    // Result: false
    
    System.out.println( ts1.contains(ts2) ? "true" : "false" );
    // Result: true
                                    
                                    ]]>
                                </eg>
                            </p>
                        </div>
                    </div>
                </div>
                <div xml:id="chap_objectModel_GabotoLibrary">
                    <head>GabotoLibrary</head>
                    <p>
                        The GabotoLibrary is used to initialize Gaboto. It also offers methods to generate the specific Gaboto
                        java classes from a configuration file.
                    </p>
                </div>
                <div xml:id="chap_objectModel_Gaboto">
                    <head>Gaboto</head>
                    <p>
                        The Gaboto object is your gateway to the underlying data. It provides low-level methods to directly
                        add or remove RDF triples from the graphs but also offers methods to work with high-level 
                        Java objects such as GabotoEntities (see <ptr target="#chap_objectModel_GabotoEntity"/>) or
                        GabotoTimeBasedEntities (see <ptr target="#chap_objectModel_GabotoTimeBasedEntity"/>). 
                    </p>
                    <p>
                        Besides adding and changing data, the Gaboto object allows you to perform simple queries
                        (e.g. does entity x exist) and is able to create snapshots 
                        (see <ptr target="#chap_objectModel_GabotoSnapshot"/>). Snapshots are a projection of parts of
                        the data to one flat RDF Graph which is much easier to query than data distributed over various
                        named graphs. The snapshot, containing all the data that was valid at some point in 1900 could, for example be
                        generated like this:
                        <eg>
                            <![CDATA[
    Gaboto gaboto = GabotoFactory.getInMemoryGaboto();
    GabotoSnapshot snap = gaboto.getSnapshot(new TimeInstant(1900, null, null));
                            ]]>
                        </eg>
                    </p>
                    
                    <div>
                        <head>Instantiating Gaboto Objects</head>
                        <p>
                            Gaboto objects cannot be instantiated directly. The <hi>GabotoFactory</hi> object
                            has to be used instead. It provides methods to create three different types of Gaboto
                            objects:
                            <list type="gloss">
                                <label>Persistent Gaboto</label>
                                <item>
                                    The resulting Gaboto object uses a database backend to store its data. However,
                                    this comes at the cost of performance, which is why this object should not be used
                                    to query the data, but only for updates.
                                </item>
                                
                                <label>In-Memory Gaboto</label>
                                <item>
                                    The in-memory Gaboto object keeps all data in an in-memory store. It is linked to
                                    the persistent Gaboto object and informed about any changes in the dataset. It should
                                    therefore not be used to change data but only for query operations.
                                </item>
                                
                                <label>Empty In-Memory Gaboto</label>
                                <item>
                                    The empty in-memory Gaboto can be used for testing. Since it is not linked to the persistent
                                    object any changes to this Gaboto model will not be persistent (unless of course you use
                                    one of the provided serialization methods).
                                </item>
                            </list>
                        </p>
                    </div>
                </div>
                
                <div xml:id="chap_objectModel_GabotoSnapshot">
                    <head>GabotoSnapshot</head>
                    <p>
                        The GabotoSnapshot is a wrapper around a projection of parts of the data in the Gaboto system
                        from multiple RDF Graphs into one. GabotoSnapshots can then be used to more easily query the
                        now flat RDF Graph or to create an internal model (see <ptr target="#chap_objectModel_GabotoEntity"/>
                        and <ptr target="#chap_objectModel_GabotoEntityPool"/>). 
                    </p>
                    <p>
                        GabotoSnapshots can be created using an <ref target="#chap_objectModel_Gaboto">Gaboto object</ref>.
                    </p>
                </div>
                
                <div xml:id="chap_objectModel_GabotoEntity">
                    <head>GabotoEntity</head>
                    <p>
                        Gaboto objects are the representation of the objects in your system in Java at a certain point in
                        time. Gaboto will generate the necessary classes automatically from the configuration file. The
                        GabotoEntity class is the common base class. In the case of OxPoints we are talking about
                        Colleges, Units and Buildings and Gaboto provides the representation of these objects in Java. 
                    </p>
                    <p>
                        GabotoEntities represent the state of an entity at a given point in time (or time span), i.e. all its
                        properties are set to the values that hold at that particular point in time (or time span). 
                        
                        For now, we will concentrate on using existing objects. We will learn more about the implementation
                        details in <ptr target="part_configuring"/>.
                    </p>
                    <div>
                        <head>Examples</head>
                        <p>
                            GabotoEntities are first-class Java objects. In this case we are creating a new Building
                            (Building is one of the defined objects in OxPoints):
                            <eg>
                                <![CDATA[
    Building b = new Building();
    b.setURI("someURI");
    b.setTimeSpan(new TimeSpan(200,0,0));
    b.setName("foo");
    
    assert(b.getName().equals("foo"));
    assert(b.getTimeSpan.contains(new TimeSpan(300,0,0,100,0,0)));
                                ]]>
                            </eg>
                        </p>
                        <p>
                            You can store entities in Gaboto using the <ref target="#chap_objectModel_Gaboto">Gaboto object</ref>:
                            <eg>
                                <![CDATA[
    Gaboto gaboto = GabotoFactory.getPersistentGaboto();
    gaboto.add(b);
                                ]]>
                            </eg>
                        </p>
                        
                        <p>
                            You can load entities from Gaboto using the <ref target="#chap_objectModel_Gaboto">Gaboto object</ref>:
                            <note>
                                For any query operation an in-memory Gaboto should be used.
                            </note>
                            <eg>
                               <![CDATA[
    Gaboto gaboto_m = GabotoFactory.getInMemoryGaboto();
    Building b1 = (Building) gaboto_m.getEntity(uri, new TimeInstant(600,0,0));
                                ]]>
                            </eg>
                            
                        </p>
                        <p>
                            Besides the type safe get and set mehtods, GabotoEntities offer a range of generic methods
                            for querying for properties:
                            <eg>
                                <![CDATA[
    // lets assume we have an entity called entity
    // GabotoEntity entity = this entity came from somewhere
    
    // let's try to find the title property described by DC:title
    String title = entity.getPropertyValue(DC.title_URI);
    System.out.println(title);
                                ]]>
                            </eg>
                        </p>
                    </div>
                    
                </div>
                
                <div xml:id="chap_objectModel_GabotoEntityPool">
                    <head>GabotoEntityPool</head>
                    <p>
                        The GabotoEntityPool is a collection of <ref target="#chap_objectModel_GabotoEntity">GabotoEntities</ref> that
                        you want to group together. You can either create an entity pool by adding entities by hand, or by parsing
                        an <ref target="#chap_objectModel_GabotoSnapshot">GabotoSnapshot</ref> (or a Jena Model) and automatically
                        extracting entities from the specified source. Simple rules and filters can be specified to guide the
                        creation process. 
                    </p>
                    <p>
                        Entity pools can then be used to do more work with the extracted entities or they can be automatically
                        transformed into different output formats (such as RDF or KML). For most queries it will be sufficient
                        to create an entity pool, containing all the entities that fulfil the query's requirements and then
                        to transform the resulting pool into whatever output format the user requested.
                    </p> 
                    <div>
                        <head>Examples</head>
                        <p>
                        Creating an entity pool containing all Colleges that currently exist:
                        <eg>
                            <![CDATA[
    Gaboto gaboto = GabotoFactory.getInMemoryGaboto();
    
    // create snapshot
    GabotoSnapshot snap = gaboto.getSnapshot(TimeInstant.now());
    
    // configure creation
    GabotoEntityPoolConfiguration config = new GabotoEntityPoolConfiguration(snap);
    config.addAcceptedType(OxPointsVocab.College_URI);
    
    // create entity pool
    GabotoEntityPool pool = GabotoEntityPool.createFrom(config);
    
    // transform to KML
    String kml = new KMLPoolTransformer().transform(pool);
                            ]]>
                        </eg>
                        </p>
                        <p>
                            In the above example, we create an entity pool through a <hi>GabotoEntityPoolConfiguration</hi> object. 
                            This configuration object offers 
                            various properties to guide the pool's creation process. For a detailed reference
                            refer to the GabotoEntityPoolConfiguration's JavaDoc. We will also tackle more examples
                            in <ptr target="#chap_query"/>.
                        </p>
                        <p>
                            Using <hi>EntityFilters</hi> to find colleges near OUCS:
                            <eg>
                                <![CDATA[
    // define some constants
	final double max_distance = 0.002;
	final double lat_oucs = 51.760010;
	final double long_oucs = -1.260350;

    // create gaboto object
    Gaboto gaboto = GabotoFactory.getInMemoryGaboto();

	// create snapshot
	GabotoSnapshot snap = gaboto.getSnapshot(TimeInstant.now());

	// configure creation
	GabotoEntityPoolConfiguration config = new GabotoEntityPoolConfiguration(snap);
	config.addAcceptedType(OxPointsVocab.College_URI);

	// add filter
	config.addEntityFilter(new EntityFilter(){
	    	
		@Override
		public boolean filterEntity(GabotoEntity entity) {
			College col = (College) entity;
	    	
	    	// reject if no primary place is set
	    	if(null == col.getPrimaryPlace())
	    		return false;
	    	
	    	// load location
	    	Location loc = col.getPrimaryPlace().getLocation();
	    	
	    	// reject if no location is set
	    	if(null == loc)
	    		return false;
	    	
			double lat_diff = loc.getLatitude() - lat_oucs;
			double long_diff = loc.getLongitude() - long_oucs;
			double distance = Math.sqrt(lat_diff*lat_diff + long_diff*long_diff);

	    	// if distance is small enough, allow entity to pass.
	    	if(distance < max_distance)
	    		return true;
	    	
	    	// reject by default
	    	return false;
		}
	});
	    	
	// create entity pool
	GabotoEntityPool pool = GabotoEntityPool.createFrom(config);

	// transform to KML
	String kml = new KMLPoolTransformer().transform(pool);
	
	// output kml to console
	System.out.println(kml);
                                ]]>
                            </eg>
                        </p>
                        <p>
                            EntityFilters are a powerful tool to select the entities that are added to the 
                            entity pool. However, since the filters can only be executed after an entity
                            was instantiated, they do not provide a very good performance. They should therefore
                            be used with care. We will learn more about this in <ptr target="#chap_query"/>.
                        </p>
                    </div>
                </div>
                
                
                <div xml:id="chap_objectModel_GabotoTimeBasedEntity">
                    <head>GabotoTimeBasedEntity</head>
                    <p>
                        <ref target="#chap_objectModel_GabotoEntity">GabotoEntities</ref> are the Java representation
                        of an Gaboto object with fixed attributes as it existed at a given point in time (or time span).
                        <hi>GabotoTimeBasedEntity</hi> represents an object over its entire lifespan containing all the properties
                        and how they changed over time. The GabotoTimeBasedEntity can be used to iterate over the entity
                        as it changed over time and it provides an easy to use interface for adding and changing time bound
                        data.
                    </p>
                    <div>
                        <head>Examples</head>
                        <p>
                            Loading an entity and traversing over all changed versions:
                            <eg>
                                <![CDATA[
    Gaboto gaboto = GabotoFactory.getInMemoryGaboto();
	GabotoTimeBasedEntity entityTB = GabotoTimeBasedEntity.loadEntity("someBuildingsURI", gaboto);

	System.out.println(entityTB.getType()); 
	// prints Building, if the URI was indeed a Building's URI

	Iterator<GabotoEntity> it = entityTB.iterator();
	while(it.hasNext()){
	    Building b = (Building) it.next();
	    System.out.println("During " + b.getTimeSpan() + " " + b.getUri() + "'s name was: " + b.getName());
	}
                                ]]>
                            </eg>
                        </p>
                        <p>
                            Creating an GabotoTimeBasedEntity:
                            <eg>
                                <![CDATA[
    TimeSpan ts = new TimeSpan(500,0,0,500,10,10);
    GabotoTimeBasedEntity entityTB = new GabotoTimeBasedEntity(Building.class, TestUtils.generateRandomURI(), ts);
    entityTB.addProperty(DC.title, name1);
                                ]]>
                            </eg>
                        </p>
                    </div>
                </div>
            </div>
            
            <div xml:id="chap_query">
                <head>Querying Gaboto</head>
                <p>
                    This chapter describes different approaches to query the Gaboto system presenting
                    their advantages and disadvantages. Since Gaboto is still in a very early phase of 
                    development and we don't have any reliable experiences with the performance of the different query
                    types described in this chapter, we can only present assumptions. 
                </p>
            
                <div>
                    <head>Different Query Types</head>
                    <p>
                        There are many different ways in which you can query data from the Gaboto system. You
                        can use high-level objects such as the <ref target="#chap_objectModel_GabotoEntityPool">GabotoEntityPool</ref>
                        or use low-level methods like SPARQL.
                    </p>
                    <div>
                        <head>The Gaboto Object Model</head>
                        <p>
                            Using the Gaboto object model, you are presented with a rich high-level
                            easy to use interface to the data. The downside to this approach is that, 
                            high-level approaches always perform (slightly) worse than optimized low-level
                            approaches. However, if you follow certain guidelines when working with the
                            Gaboto object model, the performance disadvantages should not be too severe
                            and the advantages (maintainability, time for development, etc.) should outweigh
                            the disadvantages.
                            <note>
                                While it is rather difficult to write bad SQL, that cannot be properly optimized
                                by today's query optimizers, it is very easy to write bad SPARQL queries. The algorithms
                                used in Jena to optimize queries are currently still far from being able to produce 
                                the results their SQL counterparts are able of.
                            </note>
                        </p>
                        
                        <div>
                            <head>Point Queries</head>
                            <p>
                                If we want to get information about a specific entity we can simply
                                ask the <ref target="#chap_objectModel_Gaboto">Gaboto object</ref> for it.
                                We may want to get the details of the entity at a specific point in time or we may be interested in getting the details of how it has changed over time.
                                <eg>
                                    <![CDATA[
    // get Gaboto object
    Gaboto gaboto = GabotoFactory.getInMemoryGaboto();
    
    // get entity at a specific point in time
    GabotoEntity entity = gaboto.getEntity("entityURI", TimeInstant.now());
    
    // or instead get details about how the entity has changed over time
    GabotoTimeBasedEntity entityTB = gaboto.getEntityOverTime("entityURI");
                                    ]]>
                                </eg>
                            </p>
                            <p>
                                These objects can then be used to ascertain the information you are interested in.
                            </p>
                            <div>
                                <head>Finding Entities</head>
                                <p>
                                    To run point queries you first need to find the URIs of the entities in question.
                                    <ref target="#chap_objectModel_Gaboto">Gaboto</ref> and 
                                    <ref target="#chap_objectModel_GabotoSnapshot">GabotoSnapshot</ref> provide helper methods
                                    for this task.
                                </p>
                                <div>
                                    <head>Finding Entities in Snapshots</head>
                                    <p>
                                        If you already have a snapshot that you are working with, you can create entities
                                        by calling the method <hi>loadEntitiesWithProperty</hi>. This allows you to easily
                                        create entity pools that contain only those entities that have a specific property
                                        or entities that have that property with a specific value.
                                        <eg>
                                            <![CDATA[
    // load snapshot
    GabotoSnapshot snap = gaboto.getSnapshot(TimeInstant.now());
    
    // get all entities that have the title "Somerville College"
    GabotoEntityPool pool = snap.loadEntitiesWithProperty(DC.title, "Somerville College");                                            
                                            ]]>
                                        </eg>
                                    </p>
                                    <p>
                                        In RDF properties are described using URIs. The presented methods therefore take a URI 
                                        or a Jena abstraction called <emph>Property</emph> as input for defining the property you
                                        are looking for.
                                    </p>
                                </div>
                                <div>
                                    <head>Finding Entities in the Gaboto Object</head>
                                    <p>
                                        The <ref target="#chap_objectModel_Gaboto">Gaboto</ref> object provides two mechanisms to
                                        find entities. You can either ask for a set of URIs (<emph>getEntityURIsFor</emph>) or directly create
                                        <ref target="#chap_objectModel_GabotoTimeBasedEntity">GabotoTimeBasedEntities</ref> 
                                        (<emph>loadEntitiesOverTimeWithProperty</emph>).
                                    </p>
                                    <p>
                                        This example lists all URIs of entities that have a title:
                                        <eg>
                                            <![CDATA[
    Gaboto gaboto = GabotoFactory.getInMemoryGaboto();
    		
    // get list of URIs
    Collection<String> uris = gaboto.getEntityURIsFor(DC.title);                                            
    for(String uri : uris)
        System.out.println(uri);
                                            ]]>
                                        </eg>
                                    </p>
                                    <p>
                                        Get time based entities that have the title "Somerville College":
                                        <eg>
                                            <![CDATA[
Gaboto gaboto = GabotoFactory.getInMemoryGaboto();
		
// get entities
Collection<GabotoTimeBasedEntity> tbEntities = gaboto.loadEntitiesOverTimeWithProperty(DC.title, "Somerville College");
                                            ]]>
                                        </eg>
                                        Note: although there is likely to be 
                                        only one element in the collection 
                                        when the title is "Somerville College",
                                        the collection will have many elements
                                        if the title is "Lodge".
                                    </p>
                                </div>
                            </div>
                        </div>
                        
                        <div>
                            <head>GabotoEntityPool - Complex Queries</head>
                            <p>
                                The <ref target="#chap_objectModel_GabotoEntityPool">GabotoEntityPool</ref> offers many configuration
                                properties to guide its creation process. These are outsourced to the GabotoEntityPoolConfiguration object
                                that is then used as input for GabotoEntityPool's <hi>createFrom</hi> method. For a complete description
                                of all configuration options, refer to the JavaDoc of GabotoEntityPoolConfiguration.
                            </p>
                            <div>
                                <head>Types</head>
                                <p>
                                    With the methods <hi>addAcceptedType</hi>, <hi>setAcceptedTypes</hi>, <hi>addUnacceptedType</hi> and <hi>setUnacceptedTypes</hi>
                                    you can control which types of entity are to be added to the pool. By default all types are accepted.
                                </p>
                                <p>
                                    Create pool that only contains colleges:
                                    <eg>
                                        <![CDATA[
	GabotoEntityPoolConfiguration config = new GabotoEntityPoolConfiguration(snapshot);
    config.addAcceptedType(OxPointsVocab.College_URI);
    GabotoEntityPool pool = GabotoEntityPool.createFrom(config);
                                        ]]>
                                    </eg>
                                </p>
                                <p>
                                    Create pool that contains everything but colleges:
                                    <eg>
                                        <![CDATA[
    GabotoEntityPoolConfiguration config = new GabotoEntityPoolConfiguration(snapshot);
    config.addUnacceptedType(OxPointsVocab.College_URI);
    GabotoEntityPool pool = GabotoEntityPool.createFrom(config);
                                        ]]>
                                    </eg>
                                </p>
                            </div>
                            <div>
                                <head>Resources</head>
                                <p>
                                    If you only want to transform some specific RDF resources into GabotoEntities, then you
                                    can use the methods <hi>addResource</hi> and <hi>setResources</hi> to define which resources
                                    you want transformed. By default, entities are created for all resources that can be found. 
                                </p>
                                <p>
                                    A list of resources can be obtained by either using Jena's API (use GabotoSnapshot.getModel()
                                    to obtain the underlying Jena Model of a snapshot) or by running SPARQL queries (see <ptr target="#chap_query_sparql"/>).
                                </p>
                            </div>
                            <div xml:id="chap_query_forceCreation">
                                <head>Dereferencing of Objects</head>
                                <p>
                                    Objects in an Gaboto system usually have relationships with other objects. In OxPoints a College
                                    has, for example, a primary building. These relationships have to be somehow dereferenced when creating
                                    GabotoEntities during a pool's creation. The default method is called <hi>lazy dereferencing</hi>, which
                                    means, that relationships are only dereferenced if a relationship is actually accessed. If you, for example,
                                    created a pool containing College objects, the referenced Building objects (the college's primary buildings)
                                    will only be created if your program accesses the college's primary building property. 
                                </p>
                                <p>
                                    If you know that you will need full dereferncing (this also includes references of references of
                                    references ...), you can set the parameter <emph>enableLazyDereferencing(false)</emph>.
                                </p>
                            </div>
                            <div xml:id="chap_query_addReferencedEntities">
                                <head>Add Referenced Entities to Pool</head>
                                <p>
                                    Defines whether referenced entities are added to the pool directly. By default referenced objects are
                                    not added directly, which means that if you ask the pool to give you a collection of all its entities
                                    these will not be present. 
                                </p>
                            </div>
                            <div xml:id="chap_query_entityFilters">
                                <head>Entity Filters</head>
                                <p>
                                    Entity Filters are called after an entity was loaded and before it was added to the pool.
                                    It will only be added to the pool if it passes all entity filters. Entity filters are an
                                    easy way to guide the pool creation, but since entities are first loaded they do not provide
                                    a very good performance.
                                </p>
                                <p>
                                    Simulate accepted types parameter with entity filters (only accept colleges):
                                    <eg>
                                        <![CDATA[
    Gaboto gaboto = GabotoFactory.getInMemoryGaboto();
    GabotoSnapshot snap = gaboto.getSnapshot(TimeInstant.now());
		    
    // configure pool
    GabotoEntityPoolConfiguration config = new GabotoEntityPoolConfiguration(snap);
    
    // add entity filter 
    config.addEntityFilter(new EntityFilter(){
        @Override
    	public boolean filterEntity(GabotoEntity entity) {
    		if(!(entity instanceof College))
    			return false; // reject, if entity is not a college
    		return true; // pass
    	}
    });
                                        
                                        ]]>
                                    </eg>
                                </p>
                                <p>
                                    Simulate unaccepted types (accept everything but colleges):
                                    <eg>
                                        <![CDATA[
    Gaboto gaboto = GabotoFactory.getInMemoryGaboto();
	GabotoSnapshot snap = gaboto.getSnapshot(TimeInstant.now());

	// configure pool
	GabotoEntityPoolConfiguration config = new GabotoEntityPoolConfiguration(snap);

	// add entity filter 
	config.addEntityFilter(new EntityFilter(){

	    // this filter only applies to entities of type College
		@Override
		public Class<? extends GabotoEntity> appliesTo(){
			return College.class;
		}
		
		@Override
		public boolean filterEntity(GabotoEntity entity) {
			// reject everything
			return false;
		}
	});                             
                                        ]]>
                                    </eg>
                                </p>
                            </div>
                            <div>
                                <head>Resource Filters</head>
                                <p>
                                    Resource Filters are called before an entity is loaded and work with Jena's <hi>Resource</hi> object.
                                    Since they are called a bit earlier in the creation process, they provide a better performance
                                    than <ref target="#chap_query_entityFilters">Entity Filters</ref>.
                                </p>
                                
                                <p>
                                    The implementation is similar to <ref target="#chap_query_entityFilters">Entity Filters</ref>. A method <hi>appliesTo</hi>
                                    specifies to which entity types the filter will be applied. The filter method is called <hi>filterResource</hi>.
                                </p>
                                
                                <p>
                                    Example: Find all colleges that do not have a title property with the value "Somerville College":
                                    <eg>
                                        <![CDATA[
    Gaboto gaboto = GabotoFactory.getInMemoryGaboto();
    GabotoEntityPoolConfiguration config = new GabotoEntityPoolConfiguration(snap);
	config.addAcceptedType(OxPointsVocab.College_URI);
	config.addResourceFilter(new ResourceFilter(){

	    @Override
	    public Class<? extends GabotoEntity> appliesTo(){
			return College.class; // unnecessary because of accepted types.
		}
		
		public boolean filterResource(Resource res){
		    // everything that is not somerville
		    return ! res.hasProperty(DC.title, "Somerville College");
		}

	});
	GabotoEntityPool pool = GabotoEntityPool.createFrom(config);                                       
                                        ]]>
                                    </eg>
                                </p>
                                
                                <p>
                                Note: the full name of the Resource class is com.hp.hpl.jena.rdf.model.Resource.
                                </p>
                                
                                <div>
                                    <head>Predefined Resource Filters</head>
                                    <p>
                                        <list type="gloss">
                                            <label>PropertyExistsFilter</label>
                                            <item>Tests whether resources that apply have a specific property.</item>
                                            
                                            <label>PropertyNotExistsFilter</label>
                                            <item>Tests whether resources that apply do not have a specific property.</item>
                                            
                                            <label>PropertyEqualsFilter</label>
                                            <item>Tests whether resources that apply have a specific property with a given value.</item>
                                            
                                            <label>PropertyNotEqualsFilter</label>
                                            <item>Tests whether resources that apply have a specific property with a value unequal to a given value.</item>
                                        </list>
                                    </p>
                                </div>
                            </div>
                        </div>
                        
                    </div>
                    <div xml:id="chap_query_sparql">
                        <head>SPARQL Queries</head>
                        <p>
                            SPARQL is the W3C query language for querying RDF data. It is a read-only language
                            and uses a syntax somewhere in between SQL and Datalog. Basically there are 4 different
                            types of SPARQL queries. SELECT queries are similar to SQL SELECT. You specify a set
                            of variables and restrictions and the SPARQL engine goes off and tries to find bindings
                            for these variables that match the defined restrictions. CONSTRUCT queries enable you
                            to create a new RDF Graph, that can then be used for further processing. DESCRIBE queries
                            describe entire objects and ASK queries return a boolean, indicating whether or not
                            your query statement can be matched or not.
                        </p>
                        <p>
                            For information about how to write SPARQL queries, have a look at the
                            <ref target="#chap_query_furtherReading">Further Reading section</ref>.
                        </p>
                        
                        <p>
                            The <ref target="#chap_objectModel_GabotoSnapshot">GabotoSnapshot</ref> object offers methods
                            to easily run SPARQL queries. If you want to work directly with Jena's API, aks the snapshot for the
                            underlying Jena Model object (<emph>getModel()</emph>).
                        </p>
                        
                        <div>
                            <head>Prefixes</head>
                            <p>
                                To make query writing a bit easier, you can use the static method <hi> GabotoPredefinedQueries.getStandardPrefixes()</hi>
                                to create a set of prefixes for you, that can then be used in your query. 
                                <eg>
                                    <![CDATA[
    String query = GabotoPredefinedQueries.getStandardPrefixes(); 
    System.out.println(query);
    
    /* prints:
    PREFIX dc:<http://purl.org/dc/elements/1.1/>
    PREFIX rdf:<http://www.w3.org/1999/02/22-rdf-syntax-ns#>
    PREFIX gaboto:<http://ns.ox.ac.uk/namespace/gaboto/2009/03/owl#>
    PREFIX data:<http://ns.ox.ac.uk/namespaces/oxpoints/data/>
    PREFIX rdfs:<http://www.w3.org/2000/01/rdf-schema#>
    PREFIX owl:<http://www.w3.org/2002/07/owl#>
    PREFIX xsd:<http://www.w3.org/2001/XMLSchema>
    PREFIX rdfcon:<http://ns.ox.ac.uk/namespace/rdfcontext/2009/02/owl#>
    PREFIX owl-time:<http://www.w3.org/2006/time#>
    PREFIX rdfg:<http://www.w3.org/2004/03/trix/rdfg-1/>
    PREFIX oxp:<http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#>
     */
                                     ]]>
                                </eg>
                            </p>
                        </div>
                        <div>
                            <head>SELECT Queries</head>
                            <p>
                                Print the name of all resources in a snapshot.
                                <eg>
                                    <![CDATA[
    // load snapshot
    Gaboto gaboto = GabotoFactory.getInMemoryGaboto();
    GabotoSnapshot snap = gaboto.getSnapshot(TimeInstant.now());
    
    // build query
    String query = GabotoPredefinedQueries.getStandardPrefixes();
    query += "SELECT ?uri ?name WHERE { ?uri  dc:title  ?name . }";
    
    // execute SSELECT query
    snap.execSPARQLSelect(query, new QuerySolutionProcessorImpl(){
        public void processSolution(QuerySolution solution) {
    		System.out.println(solution.getResource("uri").getURI() + " has the name: " + solution.getLiteral("name").getValue());
    	}
    });                                
                                    ]]>
                                </eg>
                            </p>
                        </div>
                        <div>
                            <head>CONSTRUCT Queries</head>
                            <p>
                                Create a new snapshot that contains all colleges that start with <hi>b</hi>:
                                <eg>
                                    <![CDATA[
    // load snapshot
    Gaboto gaboto = GabotoFactory.getInMemoryGaboto();
	GabotoSnapshot snap = gaboto.getSnapshot(TimeInstant.now());
	
    // build query
    String query = GabotoPredefinedQueries.getStandardPrefixes();
	query += "CONSTRUCT { ?a ?b ?c. } WHERE {\n" +
    		     "?a rdf:type oxp:College . \n" +
    		     "?a dc:title ?title . \n" +
    		     "FILTER regex(?title, \"^b\", \"i\") . \n" +
    		     "?a ?b ?c . \n" +
		     "}";           
		     
    // execute query
    GabotoSnapshot newSnapShot = snap.execSPARQLConstruct(query);
                                    ]]>
                                </eg>
                                <note>
                                    If you use the newly created snapshot to create an entity pool, the primary buildings
                                    will cannot be dereferenced in the resulting College objects since they are not part of the snapshot.
                                    If you want to achieve this change the pool's snapshot:
                                    <eg>
                                        <![CDATA[
        // create resultPool from model
    	GabotoEntityPool resultPool = newSnapShot.buildEntityPool();
    	
    	// change snapshot
    	resultPool.setSnapshot(snap)       
                                        ]]>
                                    </eg>
                                </note>
                            </p>
                            
                        </div>
                        <div>
                            <head>DESCRIBE Queries</head>
                            <p>
                                Create a snaphsot that only contains colleges:
                                <eg>
                                    <![CDATA[
        // load snapshot
        Gaboto gaboto = GabotoFactory.getInMemoryGaboto();
    	GabotoSnapshot snap = gaboto.getSnapshot(TimeInstant.now());
    	
    	// build query
    	String query = GabotoPredefinedQueries.getStandardPrefixes();
    	query += "DESCRIBE ?x WHERE { ?x rdf:type oxp:College }";
    	
    	// create new snapshot
    	GabotoSnapshot describedSnap = snap.execSPARQLDescribe(query);
                                    ]]>
                                </eg>
                            </p>
                        </div>
                        <div>
                            <head>ASK Queries</head>
                            <p> 
                                Ask a simple question:
                                <eg>
                                    <![CDATA[
        // load snapshot
        Gaboto gaboto = GabotoFactory.getInMemoryGaboto();
        GabotoSnapshot snap = gaboto.getSnapshot(TimeInstant.now());
        
        // build query
        String query = GabotoPredefinedQueries.getStandardPrefixes();
    	query += "ASK { data:abc123  dc:title  \"Classics Lending Library\" . }";
    	
    	// execute query
    	System.out.println( snap.execSPARQLAsk(query) ? "true" : "false" );
                                    ]]>
                                </eg>
                            </p>
                        </div>
                    </div>
                </div>

                <div>
                    <head>The GabotoQuery Interface</head>
                    <p>
                        The <hi>GabotoQuery</hi> interface and especially its abstract implementation <hi>GabotoQueryImpl</hi>
                        are meant to provide a starting point for writing reusable queries that can be used to generate
                        different output formats. They provide an interface to the user to specify an output format and will 
                        handle the transformation to that format automatically. The only thing the creator has to worry about is how to get
                        the data s/he is interested in.
                    </p>
                    <div>
                        <head>Using Existing Queries</head>
                        <p>
                            Using an GabotoQuery object is really simple. Instantiate the object, configure it, call <hi>execute</hi>
                            and tell it what output format it should generate. If we wanted to have the RDF for all carparks
                            in the system in XML abbreviated form, we could use the <hi>ListOfTypedEntities</hi> query:
                            <eg>
                                <![CDATA[
    // get Gaboto object
    Gaboto gaboto = GabotoFactory.getInMemoryGaboto();
    
    // instantiate query
    GabotoQuery loteQuery = new ListOfTypedEntities(gaboto, OxPointsVocab.Carpark_URI, TimeInstant.now());
    
    // perform query and get output 
    String output = (String) loteQuery.execute(GabotoQuery.FORMAT_RDF_XML_ABBREV);
    
    // print output
    System.out.println(output);
    
    /**
    Result:
    <rdf:RDF
        xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
        xmlns:dc="http://purl.org/dc/elements/1.1/"
        xmlns:j.0="http://www.opengis.net/gml/"
        xmlns:j.1="http://ns.ox.ac.uk/namespace/Gaboto/2009/02/owl#">
      <j.1:Carpark rdf:about="http://ns.ox.ac.uk/namespaces/Gaboto/data/carpark/6ed58a8a">
        <j.1:hasLocation>
          <j.0:Point>
            <j.0:pos>51.75966716041378 -1.25807142865529</j.0:pos>
          </j.0:Point>
        </j.1:hasLocation>
        <dc:title>Keble Triangle</dc:title>
      </j.1:Carpark>
      <j.1:Carpark rdf:about="http://ns.ox.ac.uk/namespaces/Gaboto/data/carpark/88f2cd48">
        <j.1:hasLocation>
          <j.0:Point>
            <j.0:pos>51.76312928396877 -1.259968959743287</j.0:pos>
          </j.0:Point>
        </j.1:hasLocation>
        <dc:title>Bevington Road</dc:title>
      </j.1:Carpark>
      .....
    </RDF>
    */
                                ]]>
                            </eg>
                        </p>
                        <p>
                            For a list of all supported output formats you can call the <hi>getSupportedFormats</hi> method.
                            Currently there are generic transformations (we will have a look at these in detail
                            in <ptr target="#chap_extending_transformations"/>) available for the following formats:
                            <list type="gloss">
                                <label>RDF</label>
                                <item>Various RDF formats are supported.</item>
                                
                                <label>KML</label>
                                <item>Google's geospatial XML markup.</item>
                                
                                <label>JSON</label>
                                <item>JavaScript Object Notation</item>
                                
                                <label>Jena Model</label>
                                <item>A Jena Model object (see <ptr target="#chap_jenaAPI"/>).</item>
                                
                                <label>Entity Pool</label>
                                <item>An <ref target="#chap_objectModel_GabotoEntityPool">GabotoEntityPool</ref> object.</item>
                            </list>
                            
                        </p>
                    </div>
                    
                    <div>
                        <head>Writing new custom queries</head>
                        <p>
                            Let us now try writing a query that, given a number <hi>n</hi> and a title finds us the nearest
                            <hi>n</hi> Colleges to an entity with this title (at a given point in time). The sample implementation I will show you here
                            is not in any case optimized for speed but uses easy to understand highlevel methods to achieve its
                            goal.
                        </p>
                        <p>
                            The first step is to create a subclass to GabotoQueryImpl and make it configurable
                            in the constructor. We also provide for set methods to set the two parameters title and number.
                            <eg>
                                <![CDATA[
public class CollegesNearEntity extends GabotoQueryImpl {

	private String title;
	private TimeInstant timeInstant;
	private int number;
	
	private GabotoSnapshot snapshot;
	
	private List<College> listOfColleges;
	
	public CollegesNearEntity(String title, int number, TimeInstant ti) throws GabotoException {
		super();
		this.title = title;
		this.timeInstant = ti;
		this.number = number;
	}
	
	public CollegesNearEntity(Gaboto gaboto, String title, int number, TimeInstant ti) throws GabotoException {
		super(gaboto);
		this.title = title;
		this.timeInstant = ti;
		this.number = number;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public void setNumber(int number) {
		this.number = number;
	}

	@Override
	protected void doPrepare() throws GabotoException {
		
	}
	
	@Override
	public int getResultType() {
		
	}

	@Override
	protected Object execute() throws GabotoException {
		
	}

}

                                ]]>
                            </eg>
                            You should always provide a constructor with a Gaboto object and one without it (in this
                            case Gaboto tries to instantiate an in-memory Gaboto object).
                        </p>
                        <p>
                            GabotoQueryImpl defines three abstract methods that we have to override:
                            <list type="gloss">
                                <label>doPrepare</label>
                                <item>
                                    <hi>doPrepare</hi> should be used to perform tasks that only have to be done
                                    once, before the query can be executed. We will use this to create a snapshot and
                                    produce a list of all colleges.
                                </item>
                                
                                <label>getResultType</label>
                                <item>
                                    Basically, there are two types of queries that you can write. You can either create 
                                    a Jena Model (for example using SPARQL) or low-level methods or you can create an GabotoEntityPool 
                                    that contains all the entities you are interested in. <hi>getResultType</hi> defines
                                    which kind of query you will write. The two possible return values are:
                                    <list type="bulleted">
                                        <item>GabotoQueryImpl.RESULT_TYPE_ENTITY_POOL</item>
                                        <item>GabotoQueryImpl.RESULT_TYPE_MODEL</item>
                                    </list>
                                    In this case we will create an entity pool with the resulting <hi>n</hi> colleges.
                                </item>
                                
                                <label>execute</label>
                                <item>
                                    In this method you perform the actual query. The return value is either an GabotoEntityPool or
                                    a Jena Model (depending on the return value of <hi>getResultType</hi>). 
                                </item>
                            </list>
                        </p>
                        <p>
                            We can now implement the three methods.
                        </p>
                        
                        <div>
                            <head>The resulting class</head>
                            <p>
                                <eg>
                                    <![CDATA[
package org.oucs.gaboto.sample;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

import org.oucs.gaboto.beans.Location;
import org.oucs.gaboto.entities.College;
import org.oucs.gaboto.entities.GabotoEntity;
import org.oucs.gaboto.entities.pool.GabotoEntityPool;
import org.oucs.gaboto.entities.pool.GabotoEntityPoolConfiguration;
import org.oucs.gaboto.exceptions.GabotoException;
import org.oucs.gaboto.model.Gaboto;
import org.oucs.gaboto.model.GabotoSnapshot;
import org.oucs.gaboto.model.query.GabotoQueryImpl;
import org.oucs.gaboto.timedim.TimeInstant;
import org.oucs.gaboto.vocabulary.OxPointsVocab;

import com.hp.hpl.jena.vocabulary.DC;
import com.hp.hpl.jena.vocabulary.DC_11;

public class CollegesNearEntity extends GabotoQueryImpl {

	private String title;
	private TimeInstant timeInstant;
	private int number;
	
	private GabotoSnapshot snapshot;
	
	private List<College> listOfColleges;
	
	public CollegesNearEntity(String title, int number, TimeInstant ti) throws GabotoException {
		super();
		this.title = title;
		this.timeInstant = ti;
		this.number = number;
	}
	
	public CollegesNearEntity(Gaboto gaboto, String title, int number, TimeInstant ti) throws GabotoException {
		super(gaboto);
		this.title = title;
		this.timeInstant = ti;
		this.number = number;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public void setNumber(int number) {
		this.number = number;
	}

	@Override
	protected void doPrepare() throws GabotoException {
		// create snapshot
		snapshot = getGaboto().getSnapshot(timeInstant);
		
		// get all colleges
		GabotoEntityPoolConfiguration config = new GabotoEntityPoolConfiguration(snapshot);
		config.addAcceptedType(OxPointsVocab.College_URI);
		GabotoEntityPool colleges = GabotoEntityPool.createFrom(config);
		
		// find colleges we are interested in
		listOfColleges = new ArrayList<College>();
		for(GabotoEntity en : colleges.getEntities()){
			// cast to college
			College col = (College) en;
			
			// get its location
			Location colLoc = (Location) col.getPropertyValue(OxPointsVocab.hasLocation);
			if(null == colLoc)
				continue;
			
			// add to results if not enough results yet
			listOfColleges.add(col);
		}
	}
	
	@Override
	public int getResultType() {
		return GabotoQueryImpl.RESULT_TYPE_ENTITY_POOL;
	}

	@Override
	protected Object execute() throws GabotoException {
		// find entity with name
		GabotoEntityPool entities = snapshot.loadEntitiesWithProperty(DC_11.title, title);
		Iterator<GabotoEntity> it = entities.getEntities().iterator();
		if(! it.hasNext())
			throw new IllegalArgumentException("There is no entity with that title.");
		GabotoEntity entity = it.next();
		
		// we do not know what kind of entity we have
		// but we are interested in its location. We
		// can get to this property, by calling its getPropertyValue
		// method.
		Location loc = (Location) entity.getPropertyValue(OxPointsVocab.hasLocation);
		if(null == loc)
			throw new IllegalArgumentException("The entity " + entity.getUri() + " does not have a location.");
		
		// store latitude and longitude
		final double lat = loc.getLatitude();
		final double _long = loc.getLongitude();
		
		// sort results
		Collections.sort(listOfColleges, new Comparator<College>(){

			public int compare(College c1, College c2) {
				// distance of college 1
				Location loc = (Location) c1.getPropertyValue(OxPointsVocab.hasLocation);
				double distX = Math.abs(lat - loc.getLatitude());
				double distY = Math.abs(_long - loc.getLongitude());
				double dis1 = Math.sqrt(distX*distX + distY*distY);
				
				// distance of college 2
				loc = (Location) c2.getPropertyValue(OxPointsVocab.hasLocation);
				distX = Math.abs(lat - loc.getLatitude());
				distY = Math.abs(_long - loc.getLongitude());
				double dis2 = Math.sqrt(distX*distX + distY*distY);
				
				if(dis1 < dis2)
					return -1;
				else if(dis1 > dis2)
					return 1;
				
				return 0;
			}
			
		});
		
		//create result pool
		GabotoEntityPool resultPool = new GabotoEntityPool(getGaboto(), snapshot);
		for(int i = 0; i < number && i < listOfColleges.size(); i++)
			resultPool.addEntity(listOfColleges.get(i));
		
		return resultPool;
	}
}

                                 
                                    ]]>
                                </eg>
                            </p>
                            <p>
                                This query can now be used to provide results in many different formats:
                                <eg>
                                    <![CDATA[
    // create query object that uses in memory Gaboto
    GabotoQuery query = new CollegesNearEntity("Somerville College", 5, TimeInstant.now());
    String output = (String) query.execute(GabotoQuery.FORMAT_KML);
	System.out.println(output);
                                      ]]>
                                </eg>
                                Resulting in:
                                <egXML xmlns="http://www.tei-c.org/ns/Examples">
<kml xmlns="http://www.opengis.net/kml/2.2">
    <Document>
      <Placemark>
         <name>St Anne's College</name>
         <Point>
            <coordinates>-1.262354850769043,51.76193031549332</coordinates>
         </Point>
      </Placemark>
      <Placemark>
         <name>Somerville College</name>
         <Point>
            <coordinates>-1.2613785266876,51.75943345494568</coordinates>
         </Point>
      </Placemark>
      <Placemark>
         <name>Green Templeton College</name>
         <Point>
            <coordinates>-1.262467503547,51.761257969688444</coordinates>
         </Point>
      </Placemark>
      <Placemark>
         <name>Regent's Park College</name>
         <Point>
            <coordinates>-1.2606704235076904,51.75731499956544</coordinates>
         </Point>
      </Placemark>
      <Placemark>
         <name>St Benet's Hall</name>
         <Point>
            <coordinates>-1.26084208488464,51.75807207653707</coordinates>
         </Point>
      </Placemark>
    </Document>
</kml>
                                </egXML>
	                            And:
    	                        <eg>
    	                            <![CDATA[
    	output = (String) query.execute(OxPointsQuery.FORMAT_RDF_XML_ABBREV);
    	System.out.println(output);    
    	                            ]]>
    	                        </eg>
                                Resulting in:
                                <egXML xmlns="http://www.tei-c.org/ns/Examples">
    <rdf:RDF
        xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
        xmlns:j.0="http://nwalsh.com/rdf/vCard#"
        xmlns:dc="http://purl.org/dc/elements/1.1/"
        xmlns:j.1="http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#">
        <j.1:College rdf:about="http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/a43adce8">
            <j.1:hasHomepage rdf:resource="http://www.st-benets.ox.ac.uk"/>
            <j.1:primaryPlace rdf:resource="http://ns.ox.ac.uk/namespaces/oxpoints/data/building/102e814f"/>
            <dc:title>St Benet's Hall</dc:title>
            <j.0:adr>
                <j.0:Address>
                    <j.0:street-address>38 St Giles', Oxford</j.0:street-address>
                    <j.0:postal-code>OX1 3LN</j.0:postal-code>
                </j.0:Address>
            </j.0:adr>
        </j.1:College>
        <j.1:College rdf:about="http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/c16e28a7">
            <j.1:hasITHomepage rdf:resource="http://www.st-annes.ox.ac.uk/study/undergraduate/computing_it.html"/>
            <j.1:hasHomepage rdf:resource="http://www.st-annes.ox.ac.uk/"/>
            <j.1:primaryPlace rdf:resource="http://ns.ox.ac.uk/namespaces/oxpoints/data/building/275ab0d1"/>
            <dc:title>St Anne's College</dc:title>
            <j.0:adr>
                <j.0:Address>
                    <j.0:street-address>Oxford</j.0:street-address>
                    <j.0:postal-code>OX2 6HS</j.0:postal-code>
                </j.0:Address>
            </j.0:adr>
        </j.1:College>
        <j.1:College rdf:about="http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/678b78ec">
            <j.1:hasHomepage rdf:resource="http://www.rpc.ox.ac.uk/rpc/"/>
            <j.1:primaryPlace rdf:resource="http://ns.ox.ac.uk/namespaces/oxpoints/data/building/ae870de6"/>
            <dc:title>Regent's Park College</dc:title>
            <j.0:adr>
                <j.0:Address>
                    <j.0:street-address>Oxford</j.0:street-address>
                    <j.0:postal-code>OX1 2LB</j.0:postal-code>
                </j.0:Address>
            </j.0:adr>
        </j.1:College>
        <j.1:College rdf:about="http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/b039a03c">
            <j.1:hasITHomepage rdf:resource="http://www.some.ox.ac.uk/students/it_services/"/>
            <j.1:hasHomepage rdf:resource="http://www.some.ox.ac.uk/"/>
            <j.1:primaryPlace rdf:resource="http://ns.ox.ac.uk/namespaces/oxpoints/data/building/34e05e71"/>
            <dc:title>Somerville College</dc:title>
            <j.0:adr>
                <j.0:Address>
                    <j.0:street-address>Oxford</j.0:street-address>
                    <j.0:postal-code>OX2 6HD</j.0:postal-code>
                </j.0:Address>
            </j.0:adr>
        </j.1:College>
        <j.1:College rdf:about="http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/fe041602">
            <j.1:hasHomepage rdf:resource="http://www.gtc.ox.ac.uk/"/>
            <j.1:primaryPlace rdf:resource="http://ns.ox.ac.uk/namespaces/oxpoints/data/building/8b9b83f2"/>
            <dc:title>Green Templeton College</dc:title>
            <j.0:adr>
                <j.0:Address>
                    <j.0:street-address>Oxford</j.0:street-address>
                    <j.0:postal-code>OX2 6HG</j.0:postal-code>
                </j.0:Address>
            </j.0:adr>
        </j.1:College>
    </rdf:RDF>                                    
                                </egXML>
                            </p>
                        </div>
                    </div>
                    
                </div>

                <div xml:id="chap_query_furtherReading">
                    <head>Further Reading</head>
                    
                    <list type="gloss">
                        <label>SPARQL [http://www.w3.org/TR/rdf-sparql-query/]</label>
                        <item>
                            Description of the W3C Query Language for querying RDF data.
                        </item>
                        
                        <label>ARQ [http://jena.sourceforge.net/ARQ/]</label>
                        <item>
                            Jena's SPARQL processor
                        </item>
                    </list>
                </div>
            </div>
            
            <div xml:id="chap_manageData">
                <head>Managing Data</head>
                <p>
                    In this chapter I'll describe in detail how to add, change and delete data in Gaboto and
                    give some insights on how Gaboto will store data that has been added. As with queries, Gaboto
                    provides low and high-level methods for managing data. However, for most cases you will never have
                    to bother about using the low-level methods.
                </p>
                <p>
                    The objects we will be investigating in this chapter are <ref target="#chap_objectModel_GabotoEntity">
                    GabotoEntity</ref> or rather the specific subclasses, <ref target="#chap_objectModel_GabotoTimeBasedEntity">GabotoTimeBasedEntity</ref>
                    and the <ref target="#chap_objectModel_Gaboto">Gaboto</ref> object. While GabotoEntities store the
                    data that we want to add, the Gaboto object provides the methods to actually persist the objects in
                    the underlying RDF store.
                </p>
                <p>
                    While we were using an in-memory Gaboto object while querying the system, we will be working
                    with a persistent object when managing it.
                </p>
                
                <div>
                    <head>Importing and Exporting Data</head>
                    <p>
                        The <ref target="#chap_objectModel_Gaboto">Gaboto object</ref> offers the methods <hi>read</hi>,
                        <hi>write</hi> and <hi>writeCDG</hi> which allow you to export/import data from/into various RDF formats.
                        If there is already data in the system, the imported data will be merged with the existing data.
                    </p>

                    <div>
                        <head>Example: Export to files</head>
                        <p>
                            <eg>
                            <![CDATA[
    Gaboto gaboto = GabotoFactory.getInMemoryGaboto();
 
    // store named graphs in file graphs.rdf
    File graphs = new File("graphs.rdf");
	FileOutputStream fos = new FileOutputStream(graphs);
	
	// store context description graph in cdg.rdf
	File cdg = new File("cdg.rdf");
	FileOutputStream cdg_fos = new FileOutputStream(cdg);
	
	// perform the actual export
	gaboto.write(fos);
	gaboto.writeCDG(cdg_fos);
                            ]]>
                            </eg>
                        </p>
                    </div>
                    <div>
                        <head>Example: Import from files</head>
                        <p>
                            <eg>
                                <![CDATA[
    // create empty Gaboto object 
    // this could of course also be a persistent object
	Gaboto gaboto = GabotoFactory.getEmptyInMemoryGaboto();
	
	File graphs = new File("graphs.rdf");
	FileInputStream fis = new FileInputStream(graphs);
	
	File cdg = new File("cdg.rdf");
	FileInputStream cdg_fis = new FileInputStream(cdg);
	
	gaboto.read(fis, cdg_fis);
	
	// after the import we have to recreate the time index 
	gaboto.recreateTimeDimensionIndex();                                
                                ]]>
                            </eg>
                        </p>
                    </div>
                </div>
                
                <div>
                    <head>Adding Data</head>
                    <p>
                        We will first have a quick glance at the low level methods, that allow you to directly
                        work with RDF constructs. We will then discuss the high-level methods in greater detail 
                        as you will hardly ever have to use anything else.
                    </p>
                    <div>
                        <head>Adding RDF Triples</head>
                        <p>
                            The <ref target="#chap_objectModel_Gaboto">Gaboto</ref> object offers the method
                            <hi>add</hi> that takes a Jena Triple object and an optional <ref target="#chap_objectModel_Time">TimeSpan</ref>
                            as parameters. The time span describes the validity of the triple, i.e., during the specified time
                            span the triple is valid. If no time span is provided, then the triple is universally valid,
                            meaning, that it is valid at any point in time.
                            <eg>
                                <![CDATA[
    // get Gaboto object
    Gaboto gaboto = GabotoFactory.getPersistentGaboto();
    
    // create a triple
    Triple t = new Triple(
        Node.createURI( "someSubjectURI" ),
        Node.createURI( "somePredicateURI" ),
        Node.createLiteral( "some literal" )
    );
    
    // add the triple with a time span from 1900-2000
    gaboto.add(new TimeSpan(1900,null,null,100,null,null),t);
                                ]]>
                            </eg>
                        </p>
                        <p>
                            In the above example, we added the triple
                            <eg><![CDATA[<someSubjectURI>  <somePredicateURI>  "some literal" .]]></eg>
                            to the graph that contains all triples that are valid from 1900-2000. If the graph did not yet
                            exist in the system, <hi>add</hi> would have automatically created the new graph first. If
                            we had not specified a time span, then the triple would have been added to the the special
                            <hi>generalKnowledgeGraph</hi>, the graph that contains all universally valid triples.
                        </p>
                    </div>
                    <div>
                        <head>Adding GabotoEntities and GabotoTimeBoundEntities</head>
                        <p>
                            As discussed in <ptr target="#chap_objectModel"/> GabotoEntity describes an entity as it exists
                            at a given point in time or time span, where it has a fixed set of properties. In contrast,
                            GabotoTimeBoundEntity describes an entity over its entire life span. The same applies, when these
                            objects are persisted to the underlying RDF. Persisting an GabotoEntity will put all the triples
                            that describe the entity into one graph. This can either be the GeneralKnowledgeGraph, in case, the 
                            entity did not have a life span associated with it. If it has, all the triples will be added to
                            the graph that contains the valid data for this time span. Persisting an GabotoTimeBasedEntity object
                            will usually result in spreading triples across multiple graphs.
                        </p>
                        <p>
                            Let us now create a new college and add it to the system. 
                            <eg>
                                <![CDATA[
    // get Gaboto object
    Gaboto gaboto = GabotoFactory.getPersistentGaboto();
    
    // create college and set URI
    College col = new College();
    col.setUri(gaboto.generateID("college"));
    
    // set properties
    col.setTimeSpan(new TimeSpan(1900,null,null,100,null,null));
    col.setName("AM College");
    
    // persist college in RDF
    gaboto.add(col);                                
                                ]]>
                            </eg>

                            If we happened to start off with an empty system, the resulting RDF would look like this
                            (Syntax: <ref target="http://www4.wiwiss.fu-berlin.de/bizer/TriG/">TRIG</ref>):
                            <eg>
                                <![CDATA[
    @prefix dc:      <http://purl.org/dc/elements/1.1/> .
    @prefix rdf:     <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
    
    <http://ns.ox.ac.uk/namespaces/oxpoints/graphs#gkg.rdf> { }
    
    <http://ns.ox.ac.uk/namespaces/gaboto/graphs#tg-1900~100-0-0> {<http://ns.ox.ac.uk/namespaces/oxpoints/data/college/f14de441>
              a       <http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#College> ;
              dc:title "AM College" .
    }                               
                                ]]>
                            </eg>
                            While this describes the college data, another entry is added to the <hi>contextDescriptionGraph</hi>
                            (a special graph that describes all the graphs in the system), to describe the newly created
                            <hi>http://ns.ox.ac.uk/namespaces/gaboto/graphs#tg-1900~100-0-0</hi>:
                            <eg>
                                <![CDATA[
    <http://ns.ox.ac.uk/namespaces/gaboto/graphs#tg-1900~100-0-0>
          a       <http://www.w3.org/2004/03/trix/rdfg-1/Graph> ;
          <http://ns.ox.ac.uk/namespace/rdfcontext/2009/02/owl#hasTemporalDimension>
                  [ a       <http://www.w3.org/2006/time#Interval> ;
                    <http://www.w3.org/2006/time#hasBeginning>
                            [ a       <http://www.w3.org/2006/time#Instant> ;
                              <http://www.w3.org/2006/time#hasDateTimeDescription>
                                      [ a       <http://www.w3.org/2006/time#DateTimeDescription> ;
                                        <http://www.w3.org/2006/time#unitType>
                                                <http://www.w3.org/2006/time#unitYear> ;
                                        <http://www.w3.org/2006/time#year>
                                                1900
                                      ]
                            ] ;
                    <http://www.w3.org/2006/time#hasDurationDescription>
                            [ a       <http://www.w3.org/2006/time#DurationDescription> ;
                              <http://www.w3.org/2006/time#days>
                                      0 ;
                              <http://www.w3.org/2006/time#months>
                                      0 ;
                              <http://www.w3.org/2006/time#years>
                                      100
                            ]
                  ] .
    
    <http://ns.ox.ac.uk/namespaces/gaboto/graphs#gkg.rdf>
          a       <http://ns.ox.ac.uk/namespace/rdfcontext/2009/02/owl#GlobalKnowledgeGraph> .
                                
                                ]]>
                            </eg>
                        </p>
                        <div>
                            <head>URIs</head>
                            <p>
                                When creating a new entity object that you want to add to Gaboto you have to assign it a
                                unique id. For this purpose the <ref target="#chap_objectModel_Gaboto">Gaboto</ref> object provides
                                the method <hi>generateID</hi> which makes sure that the generated ID is in fact unique. 
                                As a shortcut, GabotoEntity provides the static method
                                <hi>createNew</hi>:
                                <eg>
                                    <![CDATA[
    Gaboto gaboto = GabotoFactory.getPersistentGaboto();
    College col = GabotoEntity.createNew(oxp, new College());                                
                                    ]]>
                                </eg>
                            </p>
                        </div>
                        <div>
                            <head>GabotoTimeBasedEntities</head>
                            <p>
                                If you have an entity with a defined life span but a fixed set of properties, 
                                <ref target="#chap_objectModel_GabotoEntity">GabotoEntity</ref> is your friend. If you however,
                                have properties that changed over time, you have to work with the slightly more
                                complicated <ref target="#chap_objectModel_GabotoTimeBasedEntity">GabotoTimeBasedEntity</ref>
                                object.
                            </p>
                            <p>
                                Let's try and describe parts of the history of <hi>Oxford University Computing Services (OUCS)</hi>.
                                OUCS was founded in 1957 and was known as <hi>Computing Laboratory</hi> from 1957 to 1969. It then
                                changed names (in fact it was split in two, but we ignore this fact for this example) and is since
                                known as <hi>Oxford University Computing Services</hi>:
                                <eg>
                                    <![CDATA[
    // get persistent Gaboto object
    Gaboto gaboto = GabotoFactory.getPersistentGaboto();
    
    // instantiate GabotoTimeBasedEntity of type unit with 
    // a open ended time span starting in 1957
    GabotoTimeBasedEntity oucs = new GabotoTimeBasedEntity(Unit.class, gaboto.generateID("unit"), new TimeSpan(1957,null,null));
    
    // set the title from 1957 - 1969 and 1969 - dooms day
    oucs.addProperty(new TimeSpan(1957,null,null,12,null,null), DC.title, "Computing Laboratory");
    oucs.addProperty(new TimeSpan(1969,null,null), DC.title, "Oxford University Computing Services");
	
    // add it to the system.
    gaboto.add(oucs);                                        
                                    ]]>
                                </eg>
                            </p>
                            <p>
                                This produces the following RDF (again assuming that the system did not contain
                                any data before this):
                                <eg>
                                    <![CDATA[
    @prefix dc:      <http://purl.org/dc/elements/1.1/> .
    @prefix rdf:     <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
    
    <http://ns.ox.ac.uk/namespaces/gaboto/graphs#gkg.rdf> { }
    
    <http://ns.ox.ac.uk/namespaces/gaboto/graphs#tg-1957~12-0-0> {<http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/22596a16>
              dc:title "Computing Laboratory" .
    }
    
    <http://ns.ox.ac.uk/namespaces/gaboto/graphs#tg-1957~dooms-day> {<http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/22596a16>
              a       <http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Unit> .
    }
    
    <http://ns.ox.ac.uk/namespaces/gaboto/graphs#tg-1969~dooms-day> {<http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/22596a16>
              dc:title "Oxford University Computing Services" .
    }
                                    ]]>
                                </eg>
                            </p>
                            <p>
                                In this case three new graphs were created. One to store the associate rdf:type (Unit),
                                with an open ended time span from 1957 onwards, one from 1957-1969 claiming the unit's name
                                is <hi>Computing Laboratory</hi> and another open ended graph (1969-onwards) claiming the unit's
                                name is <hi>Oxford University Computing Services</hi>.
                            </p>
                            <p>
                                We can now query the system <note>In a productive system, you should always use an in-memory Gaboto
                                for any kind of query.</note>:
                                <eg>
                                    <![CDATA[
    Collection<GabotoTimeBasedEntity> units = gaboto.loadEntitiesOverTimeWithProperty(DC.title, "Computing Laboratory");
    for(GabotoTimeBasedEntity entityTB : units){
		System.out.println("Entity " + entityTB.getUri() + " is of type " + entityTB.getEntityClass().getSimpleName());
		
		Iterator<GabotoEntity> entityIterator = entityTB.iterator();
		while(entityIterator.hasNext()){
			Unit unit = (Unit)entityIterator.next();
			System.out.println("\tDuring " + unit.getTimeSpan() + " the entity's name was " + unit.getName());
		}
    }                
	
	/**
	 Result:
	 Entity http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/cc9ff6ae is of type Unit
  	     During 1957~12-0-0 the entity's name was Computing Laboratory
	     During 1969~dooms-day the entity's name was Oxford University Computing Services
    */
                                    ]]>
                                </eg>
                            </p>
                            <p>
                                As we have seen from the example, <hi>GabotoTimeBasedEntity</hi> is a generic object
                                applicable for all entities and does therefore not provide specialized methods like, e.g.,
                                <hi>setName</hi>. One way of adding data is (as we have done in the example) to use the
                                underlying RDF predicate to describe what kind of property you want to add. We will later
                                see (in part <ptr target="#part_configuring"/>) where these are defined.
                            </p>
                            <p>
                                Another way to add properties to <hi>GabotoTimeBasedEntity</hi> is to use <hi>GabotoEntity</hi>
                                objects. This is a less error-prone approach (but at the cost of more code lines), since you have the advantage of type aware methods.
                                Let's redo the inital example with this approach:
                                <eg>
                                    <![CDATA[
    GabotoTimeBasedEntity oucs = new GabotoTimeBasedEntity(Unit.class, gaboto.generateID("unit"), new TimeSpan(1957,null,null));
	
	 // set the title from 1957 - 1969
	Unit unit = new Unit();
	unit.setName("Computing Laboratory");
	unit.setTimeSpan(new TimeSpan(1957,null,null,12,null,null));
	oucs.addEntity(unit);
	
	// set the title from 1969 - dooms day
	unit = new Unit();
	unit.setName("Oxford University Computing Services");
	unit.setTimeSpan(new TimeSpan(1969,null,null));
	oucs.addEntity(unit);
	
	// add entity to system
	gaboto.add(oucs);
                                    ]]>
                                </eg>
                            </p>
                        </div>
                        <div xml:id="chap_manageData_type">
                            <head>The role of the <hi>rdf:type</hi> Property</head>
                            <p>
                                If you go back to the above examples, you can see that Gaboto added an <ref target="http://www.w3.org/TR/rdf-schema/#ch_type">rdf:type</ref>
                                property on oucs in the most general graph. For one thing, this property describes the resource's
                                type, telling Gaboto to load it into a <hi>Unit</hi> object. But it is also used by Gaboto to
                                derive the life span of an entity. An entity's life span is the time span of the graph where its rdf:type
                                is defined. You should therefore be careful, not to add any additional type triples, as this would
                                result in a corrupted data store for Gaboto (although it is not technically wrong RDF). However, if you
                                stick to the described high-levle methods, Gaboto should make sure, that this does not happen.
                            </p>
                        </div>
                    </div>
                </div>
                <div>
                    <head>Removing and Changing Data</head>
                    <p>
                        Technically removing and changing data is closely related, since Gaboto does not directly
                        support changing data. What happens internally if you call one of the <hi>changeEntity</hi> methods
                        of the <hi>Gaboto</hi> object is that Gaboto removes all traces of the entity (calling <emph>Gaboto.purge</emph>) and
                        then to add the new version of the entity to the system. Besides the changeEntity methods, there are various
                        <hi>remove</hi> methods that can be used for removing data. However, since these do not necessarily
                        remove an entire object but just parts (and you should therefore be very careful, if you want to use
                        them), you will usually go for the method <hi>purge</hi>, which deletes all triples that are associated
                        with the entity you want to remove from the system.
                    </p>
                </div>
            </div>
            
        </div>

        <div xml:id="part_configuring">
            <head>Part II - Configuring Gaboto</head>
        
            <p>
                In this chapter we will learn how to set up Gaboto. This mainly includes defining the entities
                that you want to be able to talk about, their relationships to one another and their properties. We will
                describe the set up process through the example of the OxPOints system.
            </p>
            
            <p>
                In order to better understand the configuration process, I will shortly describe what the system
                actually does with the finished configuration. Gaboto is a system that allows you to
                map RDF to Java classes and vice versa. In the previous examples we have already worked with GabotoEntities
                from the OxPoints system, such as <hi>College</hi>
                or <hi>Building</hi>. These classes are generated automatically by the configuration process. So what we
                are configuring is in fact the program to generate all the necessary classes that are needed to for a
                specialized Gaboto.
            </p>
        
            <div xml:id="chap_configuring_ontologies">
                <head>Ontologies</head>
                <p>
                    When setting up a new system based on Gaboto, the first step should be to think about
                    the ontologies that describe your entities. Though it is not necessary to create ontologies it will help,
                    as we have to refer to our entity types and properties as URIs and ontologies are the way to define
                    these URIs.
                </p>
                <p>
                    In the OxPoints system we use (amongst others) the following ontologies:
                    <list type="gloss">
                        <label>OxPoints Ontology</label>
                        <item>
                              The OxPoints ontology defines university entities, places and some general entities, that we
                              want to talk about in the OxPoints system.
                        </item>
                        
                        <label>Dublin Core</label>
                        <item>
                            The <ref target="http://purl.org/dc/elements/1.1/">Dublin Core</ref> ontology provides a set of general
                            and widely used properties (e.g., title). We use these, wherever applicable.
                        </item>
                        
                        <label>GEO_2007</label>
                        <item>
                            <ref target="http://www.w3.org/2005/Incubator/geo/XGR-geo-20071023/W3C_XGR_Geo_files/geo_2007.owl">GEO_2007</ref>
                            is an ontology produced by the W3C to capture some of <ref target="http://www.opengis.net/gml/">GML's</ref> features
                            in RDF. We use it to encode locations.
                        </item>
                        
                        <label>An OWL Ontology for vCards</label>
                        <item>
                            The <ref target="http://nwalsh.com/rdf/vCard">OWL Ontology for vCards</ref>, created by Norman Walsh, allows you
                            to encode vCards in RDF. We use it to encode addresses.
                        </item>
                        
                    </list>
                </p>
                
                <div xml:id="chap_ontology">
                    <head>The OxPoints Ontology</head>
                    <p>
                        Before we start going deeper into the configuration, let's have a closer look at the the OxPoints 
                        ontology. The OxPoints ontology defines all entities in the OxPoints system (Unit, College, Building, etc.)
                        and certain properties that we could not find in other, more specialized ontologies. We will later
                        see, how we use the entities and properties, defined in this ontology in the Gaboto configuration.
                    </p>
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        <xi:include href="../../ontologies/gaboto.owl"/>
                    </egXML>
                </div>
            </div>
        
            <div xml:id="chap_configuring_properties">
                <head>Properties</head>
                <p>
                    Gaboto is configured from a single XML based configuration file that defines the entities
                    (see <ptr target="#chap_objectModel_GabotoEntity"/>), their properties and the relations between
                    the different entities. Before we look at the configuration file, we will look at the
                    different kind of properties that are supported by Gaboto and how they map to RDF. 
                </p>
                <p>
                    Properties describe our entities. In RDF a property is represented (like our entities) by a URI
                    and should be defined in an ontology. One of the properties we have seen in the previous examples
                    is the <hi>title</hi> property from the <ref target="http://purl.org/dc/elements/1.1/title">Dublin Core</ref>
                    ontology. In RDF a title would look somewhat like:
                    <eg>
                        <![CDATA[
    oxpdata:someEntityURI    dc:title    "The entity's title" .                        
                        ]]>
                    </eg>
                </p>
                
                <div>
                    <head>Simple Properties</head>
                    <p>
                        Simple properties are properties that are represented by one RDF triple, where the
                        object is a literal. This can be, e.g., the title property <hi>dc:title</hi> from 
                        the previous example. 
                    </p>
                    <p>
                        Gaboto currently supports the following types:
                        <list type="bulleted">
                            <item>String</item>
                            <item>int</item>
                            <item>double</item>
                            <item>float</item>
                            <item>boolean</item>
                        </list>
                    </p>
                </div>
                <div>
                    <head>Active vs. Passive Properties</head>
                    <p>
                        When defining relationships between two entities, you have to define, with which entity
                        the actual information is stored. Take the relationship between buildings and university
                        units as an example. If we want to store that a unit occupies a certain building, we have
                        two options<note>In the Gaboto system we went for the first solution and store the information
                        together with the unit.</note>:
                        <list type="ordered">
                            <item>
                                We store the information with the unit. In RDF this could be:
                                <eg>
                                    <![CDATA[
    data:someUnitURI    oxp:occupies    data:someBuildingURI .                                    
                                    ]]>
                                </eg>
                            </item>
                            <item>
                                We store the information with the building. In RDF this could be:
                                <eg>
                                    <![CDATA[
    data:someBuildingURI    oxp:occupiedBy    data:someUnitURI .                                    
                                    ]]>
                                </eg>
                            </item>
                        </list>
                    </p>
                    <p>
                        Where you store your properties is really up to you and there is no definite right or wrong.
                        However, it is faster to load properties that are directly stored with an entity, so if you expect
                        to have lots of queries of the type <emph>what buildings belong to a unit</emph> and only very
                        few of the type <emph>what units occupy this building</emph> then you might want to store the
                        relationship with the unit for a better query performance.
                    </p>
                </div>
                <div>
                    <head>Complex Properties</head>
                    <p>
                        Complex properties are properties that consist of more than one peace of information. An address
                        for example consists of a postal code, a street address and many more fields. In Gaboto, complex
                        properties are called <hi>GabotoBean</hi><note>The term bean was chosen because of the close relationship
                            to <ref target="http://en.wikipedia.org/wiki/JavaBeans">Java Beans</ref>. A bit more on the subject of
                        Java Beans, and their relationship to GabotoBeans and GabotoEntities will be presented in <ptr target="#part_extending"/></note> and as <hi>GabotoEntity</hi>s they are first class java
                        objects. 
                        <eg>
                            <![CDATA[
    data:someUnitURI  vCard:adr [ 
                    a                  vCard:Address ;
                    vCard:postal_code    "OX3 7DQ" ;
                    vCard:street_address "Old Road Campus Research Building, off Roosevelt Drive, Oxford"
            ] ;                            
                            ]]>
                        </eg>
                    </p>
                    <p>
                        In RDF complex properties are stored using a <ref target="http://www.w3.org/TR/REC-rdf-syntax/#structuredproperties">blank node</ref>,
                        which then contains all the necessary information.
                    </p>
                </div>
                <div>
                    <head>Indirect Properties</head>
                    <p>
                        Indirect properties are properties that are not stored explicitly but can be derived from other
                        properties. We could for example define, that the location of a university unit is the location of
                        its primary building (we assume, that units have a primary building and that buildings have a location).
                        We can then derive the information by simply looking at the units primary building and searching
                        for a location there.
                        <note>The indirect property does not necessarily have to be stored directly at the next entity. This
                        can again point to a new entity, and the search is continued there.</note>
                        <note>It is possible to create infinite loops through carelessly defining indirect properties. Gaboto currently
                        does not provide any mechanisms to detect this.</note>
                    </p>
                    <p>
                        Indirect properties can also be used as fallback solutions. We could for example define, that the location
                        of a <hi>Place</hi> is either stored directly with it, but that if no location is specified, we 
                            should look at its parent Place.
                    </p>
                </div>
                <div>
                    <head>Static Properties</head>
                    <p>
                        Static properties are properties that are not stored in RDF but that are constructed using information
                        from other properties. For example, you might want to add a description to an entity that consists of its
                        title and its main website.
                    </p>
                </div>
                <div xml:id="porperties_unstoredProperty">
                    <head>Unstored Properties</head>
                    <p>
                        Unstored Properties are properties that have the same value as a stored property. In OxPoints
                        we use unstored properties to define a parent relationship that is used by the transformation to
                        KML.
                    </p>
                </div>
                <div>
                    <head>Collections</head>
                    <p>
                        In many cases you want to store lists of things. For example a building can be occupied by
                        several units. We use <ref target="http://www.w3.org/TR/REC-rdf-syntax/#collections">RDF collections</ref>
                        to achieve this. Currently only <hi>Bags (unordered lists)</hi> are implemented.
                        <eg>
                            <![CDATA[
    data:someUnitURI         oxp:occupies
                              [ a       rdf:Bag ;
                                rdf:_1  <http://ns.ox.ac.uk/namespaces/oxpoints/data/building/c8048b54> ;
                                rdf:_2  <http://ns.ox.ac.uk/namespaces/oxpoints/data/building/b11a46a1> ;
                                rdf:_3  <http://ns.ox.ac.uk/namespaces/oxpoints/data/building/865f58ae> ;
                                rdf:_4  <http://ns.ox.ac.uk/namespaces/oxpoints/data/building/25212490>
                              ] ;                            
                            ]]>
                        </eg>
                    </p>
                </div>
            </div>
            <div>
                <head> The Gaboto configuration file</head>
                <p>
                    The configuration file contains general information (such as database connection etc.),
                    and the definition of all the entities in the system, that you want to
                    store information about. To define an entity we have to specify what properties (v.s.) the entity can have.
                    The configuration file also allows us to define GabotoBeans that can then be used as complex properties.
                    The syntax for the configuration file is documented with an <ref target="#configuration_schema">XSD schema</ref>
                </p>
                <p>
                    In the case of the OxPoints system most of our entities fall into two super classes: Units and Places.
                    To be able to add properties to all entities we also introduced a common abstract super entity
                    called <hi>OxpEntity</hi>.
                    Units describe political units, such as colleges, departments, libraries etc. Places describe anything
                    that can be mapped (e.g. buildings, rooms, etc.). All these types (supertypes and subtypes) will become
                    an GabotoEntity. As for complex properties, the Gaboto system currently models a very simple address
                    (consisting of a postal code and a street address) and a location to store latitude and longitude.
                </p>
                <p>
                    Before we go into detail, let's have a look at the configuration file, the Gaboto system uses:    
                </p>
                <p>
                    <egXML xmlns="http://www.tei-c.org/ns/Examples">
<xi:include href="../config/Gaboto.xml"/>                        
                    </egXML>
                </p>

                <div>
                    <head>General Structure</head>
                    <p>
                        The configuration file is divided into three sections: A general configuration,
                        One to define GabotoBeans (complex properties) and one to define the entities.
                        <egXML xmlns="http://www.tei-c.org/ns/Examples">
                            <Gaboto>
                                <config>
                                </config>
                                <GabotoBeans>
                                </GabotoBeans>
                                <GabotoEntities>
                                </GabotoEntities>
                            </Gaboto>
                        </egXML>
                    </p>
                </div>
                <div>
                    <head>The config Section</head>
                    <p>
                        The config section defines the database connection to be used, the namespaces under
                        which data and graphs are stored and additional namespace prefixes, that will be added
                        to the default prefixes returned by <emph>GabotoPredefinedQueries.getStandardPrefixes</emph>.
                    </p>
                    
                    <div>
                        <head>Defining Database Connection</head>
                        <p>
                            Gaboto uses Jena, for its database connection 
                            (<ref target="http://jena.sourceforge.net/DB/creating-db-models.html">section on persistent models in Jena</ref>).
                            It comes shipped with the necessary JDBC libraries for MySQL and PostgreSQL.
                        </p>
                        <p>
                            Example configuration for MySQL:
                            <egXML xmlns="http://www.tei-c.org/ns/Examples">
    <database>
        <engineName>MySQL</engineName>
        <url>jdbc:mysql://localhost:8889/oxp</url>
        <user>gabotoUser</user>
        <password>gabotoPassword</password>
        <driver>com.mysql.jdbc.Driver</driver>
    </database>                                
                            </egXML>
                        </p>
                        <p>
                            Example configuration for PostgreSQL:
    <egXML xmlns="http://www.tei-c.org/ns/Examples">
        <database>
            <engineName>PostgreSQL</engineName>
            <url>jdbc:postgresql://localhost:5432/oxpoints?ssl=true</url>
            <user>gabotoUser</user>
            <password>gabotoPassword</password>
            <driver>org.postgresql.Driver</driver>
        </database>                                
    </egXML>                            
                        </p>
                    </div>
                </div>
                <div>
                    <head>Defining GabotoBeans</head>
                    <p>
                        Let's have a look at the simple <hi>Address</hi> bean:
                        <egXML xmlns="http://www.tei-c.org/ns/Examples">
                            <GabotoBean name="Address" type="&v;Address">
                                <properties>
                                    <property name="postCode" type="String" uri="&v;postal_code"/>
                                    <property name="streetAddress" type="String" uri="&v;street_address"/>
                                </properties>
                            </GabotoBean>
                        </egXML>
                    </p>
                    <p>
                        The <gi>GabotoBean</gi> element has two mandatory attributes:
                        <list type="gloss">
                            <label>name</label>
                            <item>
                                The name attribute, describes the bean's name. It should start with an
                                uppercase letter and follow the rules for Java class names, as it will be used
                                as the class name for the corresponding Java class. 
                            </item>
                            
                            <label>type</label>
                            <item>
                                The type attribute defines the type (RDF:type) of the bean. It has to be a URI.
                            </item>
                        </list>
                    </p>
                    <p>
                        Next, we have to define the properties our bean is going to have. We do this in the <gi>properties</gi>
                        section. Each <gi>property</gi> element has three mandatory attributes and an optional collection
                        attribute:
                        <list type="gloss">
                            <label>name (mandatory)</label>
                            <item>
                                The property's name is used to derive the method names for the resulting class. <hi>postCode</hi> would
                                produce the names: <hi>getPostCode</hi> and <hi>setPostCode</hi>.
                            </item>
                            
                            <label>type (mandatory)</label>
                            <item>
                                Defines the property's datatype. The datatype can either be <hi>String</hi> (mapped to an RDF Literal),
                                the name of an GabotoBean or the name of an GabotoEntity.
                            </item>
                            
                            <label>uri (mandatory)</label>
                            <item>
                                Defines the predicate URI this property should be matched to. This has to be a valid URI.
                            </item>
                            
                            <label>collection</label>
                            <item>
                                Defines whether the property stores exactly one value, or whether it stores a list of values
                                (mapped to <ref target="http://www.w3.org/TR/REC-rdf-syntax/#collections">RDF Collections</ref>).
                                Supported values are:
                                <list type="bulleted">
                                    <item><hi>bag</hi>: an unordered list.</item>
                                </list>
                            </item>
                        </list>
                    </p>
                    <div>
                        <head>The bean's RDF</head>
                        <p>
                            As we have said, GabotoBeans (or complex properties) are properties that are connected
                            to an GabotoEntity in the underlying RDF via a blank node. Here is an example of the
                            RDF produced by the Address bean.
                            <eg>
                                <![CDATA[
<http://ns.ox.ac.uk/namespaces/Gaboto/data/unit/c40051d6>
          v:adr [ a       v:Address ;
                    v:postal_code "OX2 6LY" ;
                    v:street_address "1 Church Walk, Oxford"
                  ] ;                                
                                ]]>
                            </eg>
                        </p>
                    </div>
                    <div>
                        <head>The Resulting Class</head>
                        <p>
                            From a <gi>GabotoBean</gi> element, Gaboto creates a custom Java class. Here is
                            the result for the Address bean class.
                            <eg>
                                <![CDATA[
public class Address extends GabotoBean {
	private String postCode;
	private String streetAddress;
	@Override
	public String getType(){
		return "http://nwalsh.com/rdf/vCard#Address";
	}
	@SimpleLiteralProperty("http://nwalsh.com/rdf/vCard#postal_code")
	public String getPostCode(){
		return this.postCode;
	}

	@SimpleLiteralProperty("http://nwalsh.com/rdf/vCard#postal_code")
	public void setPostCode(String postCode){
		this.postCode = postCode;
	}

	@SimpleLiteralProperty("http://nwalsh.com/rdf/vCard#street_address")
	public String getStreetAddress(){
		return this.streetAddress;
	}

	@SimpleLiteralProperty("http://nwalsh.com/rdf/vCard#street_address")
	public void setStreetAddress(String streetAddress){
		this.streetAddress = streetAddress;
	}

	public void loadFromResource(Resource res, GabotoSnapshot snapshot, GabotoEntityPool pool) {
		super.loadFromResource(res, snapshot, pool);
		Statement stmt;

		stmt = res.getProperty(snapshot.getProperty("http://nwalsh.com/rdf/vCard#postal_code"));
		if(null != stmt && stmt.getObject().isLiteral())
			this.setPostCode(((Literal)stmt.getObject()).getString());

		stmt = res.getProperty(snapshot.getProperty("http://nwalsh.com/rdf/vCard#street_address"));
		if(null != stmt && stmt.getObject().isLiteral())
			this.setStreetAddress(((Literal)stmt.getObject()).getString());

	}
}
                                ]]>
                            </eg>
                        </p>
                        <p>
                            We will have a look at the meaning of the annotations and the <hi>loadFromResource</hi>
                            method in <ptr target="#part_extending"/>.
                        </p>
                    </div>
                    <div>
                        <head>Custom Methods</head>
                        <p>
                            In some cases, you might want to add custom helper methods to a bean class. For this
                            purpose you can use the <gi>customMethods</gi> element (at the same level as <gi>properties</gi>)
                            containing <gi>method</gi> elements. <gi>method</gi> can then contain plain Java code, that is
                            added to the class.                            
                        </p>
                    </div>
                </div>
                <div>
                    <head>Defining GabotoEntities</head>
                    <p>
                        The configuration for GabotoEntities is similar to GabotoBeans but as you might guess
                        a bit more complex. Let's start with a simple entity: <hi>Image</hi>
                        <egXML xmlns="http://www.tei-c.org/ns/Examples">
                            <GabotoEntity name="Image" type="&oxp;Image">
                                <properties>
                                    <property name="width" type="String" uri="&oxp;width"/>
                                    
                                    <property name="height" type="String" uri="&oxp;height"/>
                                    
                                    <property name="imageOf" type="GabotoEntity" collection="bag" uri="&oxp;imageOf"/>
                                </properties>
                            </GabotoEntity>
                        </egXML>
                    </p>
                    <p>
                        An GabotoEntity is defined using the <gi>GabotoEntity</gi> element. This element has
                        two mandatory and one optional attributes:
                        <list type="gloss">
                            <label>name (mandatory)</label>
                            <item>
                                The name attribute, describes the entity's name. It should start with an
                                uppercase letter and following the rules for Java class names, as it will be used
                                as the class name for the corresponding Java class. 
                            </item>
                            
                            <label>type (mandatory)</label>
                            <item>
                                The type attribute defines the type (RDF:type) of the entity. It has to be a URI.
                            </item>
                            
                            <label>abstract</label>
                            <item>
                                If set to <emph>true</emph>, then the resulting class will be labeled as abstract.
                            </item>
                        </list>
                    </p>
                    <p>
                        Each <gi>property</gi> element has three mandatory attributes and an optional collection
                        attribute:
                        <list type="gloss">
                            <label>name (mandatory)</label>
                            <item>
                                The property's name is used to derive the method names for the resulting class. <hi>imageOf</hi> would
                                produce the names: <hi>getImageOf</hi>, <hi>setImageOf</hi> and <hi>addImageOf</hi><note>
                                    The add method is added whenever you have a collection property.
                                </note>.
                            </item>
                            
                            <label>type (mandatory)</label>
                            <item>
                                Defines the property's datatype. The datatype can either be <hi>String</hi> (mapped to an RDF Literal),
                                the name of an GabotoBean or the name of an GabotoEntity.
                            </item>
                            
                            <label>uri (mandatory)</label>
                            <item>
                                Defines the predicate URI this property should be matched to. This has to be a valid URI.
                            </item>
                            
                            <label>collection</label>
                            <item>
                                Defines whether the property stores exactly one value, or whether it stores a list of values
                                (mapped to <ref target="http://www.w3.org/TR/REC-rdf-syntax/#collections">RDF Collections</ref>).
                                Supported values are:
                                <list type="bulleted">
                                    <item><hi>bag</hi>: an unordered list.</item>
                                </list>
                            </item>
                        </list>
                    </p>
                    <p>
                        So far not much new. Let's have a look at a more complex entity:
                        <egXML xmlns="http://www.tei-c.org/ns/Examples">
                            <GabotoEntity name="Place" type="&oxp;Place">
                                <properties>
                                    <property name="name" type="String" uri="&dc;title"/>
                                    
                                    <property name="parent" type="Place"
                                        uri="&oxp;physicallyContainedWithin">
                                        <indirectProperty uri="&oxp;hasLocation"/>
                                    </property>
                                    
                                    <property name="location" type="Location" uri="&oxp;hasLocation"/>
                                    
                                    <property name="address" type="Address" uri="&v;adr"/>
                                    
                                    <property name="homepage" type="Website" uri="&oxp;hasHomepage"/>
                                    
                                    <passiveProperty name="containedPlaces" type="Place" relationshipType="1:N"
                                        uri="&oxp;physicallyContainedWithin"/>
                                </properties>
                                
                                <GabotoEntities>
                                    <GabotoEntity name="Building" type="&oxp;Building">
                                        <properties>
                                            <passiveProperty name="occupiedBy" type="Unit"
                                                relationshipType="N:M" uri="&oxp;occupies"/>
                                        </properties>
                                        
                                    </GabotoEntity>
                                    
                                    <GabotoEntity name="Carpark" type="&oxp;Carpark"/>
                                    
                                    <GabotoEntity name="DrainCover" type="&oxp;DrainCover"/>
                                    
                                    <GabotoEntity name="Entrance" type="&oxp;Entrance"/>
                                    
                                    <GabotoEntity name="Room" type="&oxp;Room"/>
                                    
                                    <GabotoEntity name="Site" type="&oxp;Site"/>
                                    
                                    <GabotoEntity name="WAP" type="&oxp;WAP"/>
                                </GabotoEntities>
                            </GabotoEntity>
                        </egXML>
                    </p>
                    <div>
                        <head>Inheritance</head>
                        <p>
                            <gi>GabotoEntity</gi> can contain a <gi>GabotoEntities</gi> element. With this
                            it is possible to create an inheritance structure which is then mapped to Java. In the case
                            of Place the entities Building, Carpark, DrainCover, Entrance, Room, Site and WAP are sub types
                            and therefore inherit all the properties defined on Place. 
                        </p>
                    </div>
                    <div>
                        <head>Indirect Properties</head>
                        <p>
                            Each <gi>property</gi> element can have multiple <gi>indirectProperty</gi> child elements. An indirect
                            property serves two objectives:
                            <list type="ordered">
                                <item>
                                    In case you do not have a direct property defined (active, static and unstored)                
                                    for this URI, then Gaboto will search for
                                    that property in the entity returned by the outer property definition.
                                </item>
                                <item>
                                    In case you have a direct property defined for this URI, Gaboto uses the indirect property as
                                    a fallback solution in case the return value from the direct property is null.
                                </item>
                            </list>
                        </p>
                        <p>
                            Let us have a look at the example. In the example, the property (with the uri <hi>&oxp;physicallyContainedWithin</hi>)
                            has an indirect property definition for the property <hi>&oxp;hasLocation</hi>. This means, that if
                            you ask an object of type Place for the property <hi>hasLocation</hi> it will since it has a direct
                            property defined for it, first check the direct property and return its value if it is not null. If it
                            is null, it will take the result of the property <hi>physicallyContainedWithin</hi> (which returns an GabotoEntity)
                            and search for the <hi>hasLocation</hi> property there. 
                        </p>
                        <p>
                            Another example (now case 2) would be the location of a Unit. A Unit does not have a direct property
                            for <hi>hasLocation</hi>. But we have defined that the location of a Unit is the location of its 
                            primary building (described by the property <hi>hasPrimaryBuilding</hi>). 
                        </p>
                        <p>
                            Since indirect properties try to search for a property at a different entity, they can naturally only
                            be defined on properties, that describe a relationship with another entity (store another entity).
                        </p>
                        <div>
                            <head>Multiple Alternatives</head>
                            <p>
                                In some cases you might want to specify more than one "alternative" using indirect
                                properties. For example for Units, we might want to say, that the location should be searched
                                for in its primary building, if this fails, then go to the super Unit and search for
                                the location there. We can do this by adding another attribute <hi>n</hi> on the
                                <gi>indirectProperty</gi> elements which takes a natural number (starting with 1) and defines the order
                                in which the indirect properties should be processed.<note>If <hi>n</hi> is not defined, the
                                default <hi>1</hi> will be assumed.</note>
                                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                                    <GabotoEntity name="Unit" type="&oxp;Unit">
                                        <properties>
                                            ...
                                            <property name="primaryPlace" type="Place" uri="&oxp;primaryPlace">
                                                <indirectProperty uri="&oxp;hasLocation" n="1"/>
                                            </property>
                                            
                                            <property name="subsetOf" type="Unit" uri="&oxp;subsetOf">
                                                <indirectProperty uri="&oxp;hasLocation" n="2"/>
                                            </property>
                                            ...
                                        </properties>
                                        ...
                                    </GabotoEntity>
                                </egXML>
                            </p>
                        </div>
                        <div>
                            <head>Method Creation</head>
                            <p>
                                By default no methods are created for indirect properties. If you want Gaboto to create a
                                get method for you, you have to add a name attribute onto the <gi>indirectProperty</gi> 
                                element. 
                                Note: Currently methods to look up indirect properties are not type safe. This means that
                                they will return an object of type <hi>Object</hi> and you have to manually cast it.
                                
                            </p>
                        </div>
                    </div>
                    <div>
                        <head>Passive Properties</head>
                        <p>
                            If an entity has a relationship with another entity, but the information about this
                            relationship is stored with the other entity, we can add a <gi>passiveProperty</gi> element
                            to tell Gaboto to include methods, that automatically dereference the properties and
                            allow for easy access.
                        </p>
                        <p>
                            Places, for example, have the property <hi>physicallyContainedWithin</hi>. So each place
                            directly knows its parent. If we now wanted to be able to tell, what places a place contains,
                            we had to dereference the property and search for it "backwards". Adding a <hi>passive property</hi>
                            will do all that and we can access the contained places like any other property.
                            
                            <egXML xmlns="http://www.tei-c.org/ns/Examples">
                                <passiveProperty name="containedPlaces" type="Place" relationshipType="1:N" uri="&oxp;physicallyContainedWithin"/>
                            </egXML>
                        </p>
                        <p>
                            The <gi>passiveProperty</gi> element has four mandatory attributes:
                            <list type="gloss">
                                <label>name</label>
                                <item>
                                    The property's name. The name is used to derive the method names. In the example
                                    a method <hi>getContainedPlaces</hi> would be created.
                                </item>
                                
                                <label>type</label>
                                <item>
                                    The type of the GabotoEntity where the actual property is stored.
                                </item>
                                
                                <label>relationshipType</label>
                                <item>
                                    Defines the cardinality of the relationship. The first part describes the number of 
                                    entities that take part in the relationship, of the type where the passive property is defined.
                                    The second part describes the number of entities that take part in the relationship, of the type
                                    where the actual property is defined.
                                    Allowed values are:
                                    <list type="gloss">
                                        <label>1:N</label>
                                        <item>
                                            Example: One place contains many places, whereas each place is only directly contained in
                                            one other place.
                                        </item>
                                        <label>N:M</label>
                                        <item>
                                            Example: A unit occupies many buildings and each building may be occupied by multiple units.
                                        </item>
                                        </list>
                                </item>
                                <label>uri</label>
                                <item>
                                    The URI, that describes the property.
                                </item>
                            </list>
                        </p>
                        <div>
                            <head>Set- and Add- Methods</head>
                            <p>
                                Even though passive properties will create set (and sometimes add) methods, these should not
                                be used. They are only used when loading the data from RDF and whatever is stored in a passive 
                                property will have no effect, when storing the entity.
                            </p>
                        </div>
                    </div>
                    <div>
                        <head>Custom Methods</head>
                        <p>
                            As is the case with GabotoBeans, you might want to add custom helper methods to an entity class. For this
                            purpose you can use the <gi>customMethods</gi> element (at the same level as <gi>properties</gi>)
                            containing <gi>method</gi> elements. <gi>method</gi> can then contain plain Java code, that is
                            added to the class.                            
                        </p>
                    </div>
                    <div>
                        <head>Static Properties</head>
                        <p>
                            You might have noticed, that most of the methods that are automatically generated are annotated using
                            <ref target="http://en.wikipedia.org/wiki/Java_annotation">Java Annotations</ref>. Using 
                            <ref target="http://java.sun.com/docs/books/tutorial/reflect/index.html">reflection</ref> Gaboto takes
                            these annotations to figure out how to create RDF for the various properties<note>This could be in fact
                            changed to also create the appropriate methods for RDF generation during the creation of the class. However,
                            since this is (at least at the moment) not a time critical task, reflection is more than adequate for
                            the job</note>. More importantly however, the annotations are used by the general output transformers
                            (such as KML, JSON, etc.).
                        </p>
                        <p>
                            In order to generate output for any kind of GabotoEntity, the general output transformers treat
                            each entity not as a specific entity (such as college, building etc.) but as an GabotoEntity, that 
                            has certain properties. The KML transformer, for example, simply checks for the following properties:
                            <list type="gloss">
                                <label>&dc;title</label>
                                <item>
                                    The dublin core title property.
                                </item>
                                
                                <label>&dc;description</label>
                                <item>
                                    The dublin core description property, which is used as an optional description. This
                                    can contain HTML.
                                </item>
                                
                                <label>&oxp;hasLocation</label>
                                <item>
                                    The Gaboto location attribute, used to define the entity's location.
                                </item>
                            </list>
                        </p>
                        <p>
                            In some cases, as, for example, with the <hi>&dc;description</hi> property, you might not want to 
                            actually store this property in the database, but be able to generate it "on the fly" by combining
                            various bits of information. For this purpose you can create <hi>custom methods</hi> and annotate
                            these with the <hi>StaticProperty</hi> annotation. The single parameter to the annotation is the 
                            property's URI. The method should have no parameters, and the return value should (naturally)
                            correspond to the definition of the property (in the case of &dc;description the return value
                            should be a string).
                            <egXML xmlns="http://www.tei-c.org/ns/Examples">
                                <GabotoEntity name="Unit" type="&oxp;Unit">
                                    <properties>
                                        ...
                                    </properties>
                                    
                                    <customMethods>
                                        <method>
                                            <![CDATA[
    @StaticProperty("http://purl.org/dc/elements/1.1/description")
    public String getDescription(){
        String description = "";
        
        if(null != getHomepage())
            description += "Website: <a href=\"" + getHomepage().getUri() + "\">" + getHomepage().getUri() + "</a><br/>";
        if(null != getImages() && getImages().size() > 0){
        	Image img = getImages().iterator().next();
        	description += "<img src=\"" + img.getUri() + "\" width=\"" + img.getWidth() + "\" height=\"" + img.getHeight() + "\"/>";
        }
        
        return description;
    }
                    ]]>
                                        </method>
                                    </customMethods>
                                    
                                    <GabotoEntities>
                                        ...
                                    </GabotoEntities>
                                </GabotoEntity>                                
                            </egXML>
                        </p>
                    </div>
                    <div>
                        <head>Unstored Properties</head>
                        <p>
                            Unstored properties are properties that have the same value as a stored property, but that
                            are not persisted. They are mainly used by tools (e.g. transformation tools) that work with GabotoEntities
                            in a generic way. For example the KML transformation looks for a property called
                            <emph>&gabotoKML;parent</emph> when it constructs the title of a placemark. If it finds
                            the <emph>parent</emph> attribute it will add the parent's title to the title to create
                            a comma separated list of titles:
                            <egXML xmlns="http://www.tei-c.org/ns/Examples">
    <kml xmlns="http://www.opengis.net/kml/2.2">
        <Document>
            <Placemark>
                <name>All Souls College Library, All Souls College</name>
                <description><![CDATA[Website: <a href="http://www.all-souls.ox.ac.uk/library/">http://www.all-souls.ox.ac.uk/library/</a><br/>]]></description>
                <Point>
                    <coordinates>-1.253042221069336,51.75278555467572</coordinates>
                </Point>
            </Placemark>
        </Document>
    </kml>
        
                            </egXML>
                        </p>
                        <p>
                            Usually you have such properties already defined in a more specific ontology. Here is the
                            example of OxPoints Unit:
                            <egXML xmlns="http://www.tei-c.org/ns/Examples">
                                <GabotoEntity name="Unit" type="&oxp;Unit">
                                    <properties>
                                        ...
                                        <property name="subsetOf" type="Unit" uri="&oxp;subsetOf">
                                            <indirectProperty uri="&oxp;hasLocation" n="3"/>
                                            <unstoredProperty uri="&gabotoKML;parent"/>
                                        </property>
                                        ...    
                                    </properties>
                                    ...
                                    <GabotoEntities>
                                        ...
                                    </GabotoEntities>
                                </GabotoEntity>
                            </egXML>
                        </p>
                        <p>
                            You can add as many unstored properties into a property element as you like. If you add
                            a name attribute getMethods will be created.
                        </p>
                    </div>
                    <div>
                        <head>The resulting Java Class for Place</head>
                        <eg>
                            <![CDATA[
package org.oucs.gaboto.entities;

import java.util.HashMap;
import java.util.Map;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
import java.util.List;
import java.util.ArrayList;
import java.lang.reflect.Method;
import org.oucs.gaboto.entities.utils.SimpleLiteralProperty;
import org.oucs.gaboto.entities.utils.SimpleURIProperty;
import org.oucs.gaboto.entities.utils.ComplexProperty;
import org.oucs.gaboto.entities.utils.BagURIProperty;
import org.oucs.gaboto.entities.utils.BagLiteralProperty;
import org.oucs.gaboto.entities.utils.BagComplexProperty;
import org.oucs.gaboto.entities.utils.IndirectProperty;
import org.oucs.gaboto.entities.utils.UnstoredProperty;
import org.oucs.gaboto.entities.utils.PassiveProperty;
import org.oucs.gaboto.entities.utils.StaticProperty;
import org.oucs.gaboto.vocabulary.*;
import org.oucs.gaboto.entities.GabotoEntity;
import org.oucs.gaboto.entities.pool.GabotoEntityPool;
import org.oucs.gaboto.entities.pool.EntityExistsCallback;
import org.oucs.gaboto.entities.pool.PassiveEntitiesRequest;
import org.oucs.gaboto.model.GabotoSnapshot;
import com.hp.hpl.jena.rdf.model.Resource;
import com.hp.hpl.jena.rdf.model.Statement;
import com.hp.hpl.jena.rdf.model.StmtIterator;
import com.hp.hpl.jena.rdf.model.Property;
import com.hp.hpl.jena.rdf.model.Literal;
import com.hp.hpl.jena.rdf.model.Bag;
import com.hp.hpl.jena.rdf.model.NodeIterator;
import com.hp.hpl.jena.rdf.model.RDFNode;
import com.hp.hpl.jena.ontology.OntClass;
import org.oucs.gaboto.entities.OxpEntity;
import org.oucs.gaboto.beans.Location;
import org.oucs.gaboto.beans.Address;


/**
 *<p>This class was automatically generated by Gaboto<p>
 */
public class Place extends OxpEntity {
	private String name;
	private Place parent;
	private Location location;
	private Address address;
	private Website homepage;
	private Collection<Place> containedPlaces;


	private static Map<String, List<Method>> indirectPropertyLookupTable;
	static{
		indirectPropertyLookupTable = new HashMap<String, List<Method>>();
		List<Method> list;

		try{
			list = new ArrayList<Method>();
			list.add(Place.class.getMethod("getParent", (Class<?>[])null));
			indirectPropertyLookupTable.put("http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#hasLocation", list);

		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	@Override
	public String getType(){
		return "http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Place";
	}

	@SimpleLiteralProperty(
		value = "http://purl.org/dc/elements/1.1/title",
		datatypeType = "javaprimitive",
		javaType = "String"
	)
	public String getName(){
		return this.name;
	}

	@SimpleLiteralProperty(
		value = "http://purl.org/dc/elements/1.1/title",
		datatypeType = "javaprimitive",
		javaType = "String"
	)
	public void setName(String name){
		this.name = name;
	}

	@UnstoredProperty({"http://ns.ox.ac.uk/namespace/gaboto/kml/2009/03/owl#parent"})
	@IndirectProperty({"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#hasLocation"})
	@SimpleURIProperty("http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#physicallyContainedWithin")
	public Place getParent(){
		if(! this.isDirectReferencesResolved())
			this.resolveDirectReferences();
		return this.parent;
	}

	@SimpleURIProperty("http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#physicallyContainedWithin")
	public void setParent(Place parent){
		if( null != parent)
			this.removeMissingReference( parent.getUri() );
		this.parent = parent;
	}

	@ComplexProperty("http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#hasLocation")
	public Location getLocation(){
		return this.location;
	}

	@ComplexProperty("http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#hasLocation")
	public void setLocation(Location location){
		this.location = location;
	}

	@ComplexProperty("http://nwalsh.com/rdf/vCard#adr")
	public Address getAddress(){
		return this.address;
	}

	@ComplexProperty("http://nwalsh.com/rdf/vCard#adr")
	public void setAddress(Address address){
		this.address = address;
	}

	@SimpleURIProperty("http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#hasHomepage")
	public Website getHomepage(){
		if(! this.isDirectReferencesResolved())
			this.resolveDirectReferences();
		return this.homepage;
	}

	@SimpleURIProperty("http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#hasHomepage")
	public void setHomepage(Website homepage){
		if( null != homepage)
			this.removeMissingReference( homepage.getUri() );
		this.homepage = homepage;
	}

	@PassiveProperty(
		uri = "http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#physicallyContainedWithin",
		entity = "Place"
	)
	public Collection<Place> getContainedPlaces(){
		if(! isPassiveEntitiesLoaded() )
			loadPassiveEntities();
		return this.containedPlaces;
	}

	@PassiveProperty(
		uri = "http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#physicallyContainedWithin",
		entity = "Place"
	)
	private void setContainedPlaces(Collection<Place> containedPlaces){
		this.containedPlaces = containedPlaces;
	}

	private void addContainedPlace(Place containedPlace){
		if(null == this.containedPlaces)
			this.containedPlaces = new HashSet<Place>();
		this.containedPlaces.add(containedPlace);
	}


	public Collection<PassiveEntitiesRequest> getPassiveEntitiesRequest(){
		Collection<PassiveEntitiesRequest> requests = super.getPassiveEntitiesRequest();
		if(null == requests)
			requests = new HashSet<PassiveEntitiesRequest>();
		requests.add(new PassiveEntitiesRequest(){
			public String getType() {
				return "http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Place";
			}

			public String getUri() {
				return "http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#physicallyContainedWithin";
			}

			public int getCollectionType() {
				return GabotoEntityPool.PASSIVE_PROPERTY_COLLECTION_TYPE_NONE;
			}

			public void passiveEntityLoaded(GabotoEntity entity) {
				addContainedPlace((Place)entity);
			}
		});
		return requests;
	}


	public void loadFromSnapshot(Resource res, GabotoSnapshot snapshot, GabotoEntityPool pool) {
		super.loadFromSnapshot(res, snapshot, pool);
		Statement stmt;

		stmt = res.getProperty(snapshot.getProperty("http://purl.org/dc/elements/1.1/title"));
		if(null != stmt && stmt.getObject().isLiteral())
			this.setName(((Literal)stmt.getObject()).getString());

		stmt = res.getProperty(snapshot.getProperty("http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#physicallyContainedWithin"));
		if(null != stmt && stmt.getObject().isResource()){
			Resource missingReference = (Resource)stmt.getObject();
			EntityExistsCallback callback = new EntityExistsCallback(){
				public void entityExists(GabotoEntityPool pool, GabotoEntity entity) {
					setParent((Place)entity);
				}
			};
			this.addMissingReference(missingReference, callback);
		}

		stmt = res.getProperty(snapshot.getProperty("http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#hasLocation"));
		if(null != stmt && stmt.getObject().isAnon()){
			Location location = new Location();
			location.loadFromResource((Resource)stmt.getObject(), snapshot, pool);
			setLocation(location);
		}

		stmt = res.getProperty(snapshot.getProperty("http://nwalsh.com/rdf/vCard#adr"));
		if(null != stmt && stmt.getObject().isAnon()){
			Address address = new Address();
			address.loadFromResource((Resource)stmt.getObject(), snapshot, pool);
			setAddress(address);
		}

		stmt = res.getProperty(snapshot.getProperty("http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#hasHomepage"));
		if(null != stmt && stmt.getObject().isResource()){
			Resource missingReference = (Resource)stmt.getObject();
			EntityExistsCallback callback = new EntityExistsCallback(){
				public void entityExists(GabotoEntityPool pool, GabotoEntity entity) {
					setHomepage((Website)entity);
				}
			};
			this.addMissingReference(missingReference, callback);
		}

	}
	public List<Method> getIndirectMethodsForProperty(String propertyURI){
		List<Method> list = super.getIndirectMethodsForProperty(propertyURI);
		if(null == list)
			return indirectPropertyLookupTable.get(propertyURI);
		
		else{
			List<Method> tmp = indirectPropertyLookupTable.get(propertyURI);
			if(null != tmp)
				list.addAll(tmp);
		}
		return list;
	}

}    
                            ]]>
                        </eg>
                    </div>
                </div>
            </div>
            <div>
                <head>Generating the Java Files from the Configuration</head>
                <div>
                    <head>From the Command Line</head>
                    <p>
                        To generate the Java classes from the configuration file run:
                        <eg>
                            <![CDATA[
        org.oucs.gaboto.helperscripts.CreateClassesFromConfiguration  configfile outputdirEntities outputdirBeans outputdirMisc                         
                            ]]>
                        </eg>
                    </p>
                    <p>
                        You should then copy all the beans to org.oucs.gaboto.beans, all the entities to
                        org.oucs.gaboto.entities and all the misc files to org.oucs.gaboto.util and recompile
                        the Gaboto Library.
                    </p>
                </div>
                <div>
                    <head>From within Java</head>
                    <p>
                        The <ref target="#chap_objectModel_GabotoLibrary">GabotoLibrary</ref> offers a method to
                        trigger the generation of classes.
                    </p>
                </div>
                <div>
                    <head>Using Apache Ant</head>
                    <p>
                        See <ptr target="#compilingGaboto"/>.
                    </p>
                </div>    
            </div>
      </div>
              
        <div xml:id="part_extending">
            <head>Part III - Extending Gaboto</head>
            
            <div>
                <head>Working with the Gaboto Code</head>
                <p>
                    This section describes tools that should be used when developing Gaboto and
                    how to compile new versions.
                </p>
                
                <div>
                    <head>Test Driven Development with JUnit</head>
                    <p>
                         Most of Gaboto's more important objects were/are tested using unit tests
                         (using <ref target="http://www.junit.org/">JUnit</ref>). Currently
                         Gaboto contains a test suit with 50+ test cases (in package:
                         org.oucs.gaboto.test). Whenever any changes to Gaboto are made, 
                         these tests should still run successfully (unless you have a very
                         good explanation)
                        <note>
                            The only test that is allowed to fail is <hi>testModelSizeEquality</hi>.
                            However, the difference between the expected and the actual value shouldn't
                            be too high (java.lang.AssertionError: expected:14616 but was:14615,
                            would be ok).                              
                         </note>.
                    </p>
                    <p>
                        As some of the tests add and remove triples the tests should not be run against
                        a productive system.
                    </p>
                </div>
                
                <div xml:id="transformOntologyIntoJava">
                    <head>Transforming Ontologies into Java Helper Classes</head>
                    <p>
                        Typing in long URIs is hazardous and error prone. Jena therefore offers a 
                        small utility to create Java helper classes for OWL and RDFS ontologies
                        called <ref target="http://jena.sourceforge.net/how-to/schemagen.html">schemagen</ref>.
                        The utility can be run from the command line, or via an ant task.
                        Here is an example ant task to transform the vCard ontology. For more examples
                        have a look at the ant build file <hi>build.xml</hi>.
                        
                        <egXML xmlns="http://www.tei-c.org/ns/Examples">
                            <java classname="jena.schemagen" classpathref="eclp" fork="yes">
                                <arg value="-i" />
                                <arg value="ontologies/vCard.owl" />
                                <arg value="-n" />
                                <arg value="VCard" />
                                <arg value="-o" />
                                <arg value="${vocab.dir}" />
                                <arg value="--ontology" />
                                <arg value="--package" />
                                <arg value="org.oucs.gaboto.vocabulary"/>
                            </java>
                        </egXML>
                    </p>
                    <p>
                        To run the schema generation call:
                        <eg>
    ant schemas
                        </eg>
                    </p>
                </div>
                
                <div xml:id="compilingGaboto">
                    <head>Compiling Gaboto</head>
                    <p>
                        Gaboto can be compiled using the provided <ref target="http://ant.apache.org/">ant</ref> build script.
                        Available ant targets are:
                        <list type="gloss">
                            <label>compile</label>
                            <item>
                                Compiles gaboto.
                            </item>

                            <label>debploy</label>
                            <item>
                                This is the default ant task. It will compile Gaboto and copy a Gaboto.jar file
                                and a Gaboto.zip (containing documentation, Gaboto.jar and all necessary libraries)
                                to the deploy directory.
                            </item>
                            
                            <label>gabotoConfiguration</label>
                            <item>
                                Reads the configuration and copies the created classes to the correct positions.
                            </item>
                            
                            <label>configureAndDeploy</label>
                            <item>
                                Creates the necessary classes from the configuration, compiles and deploys Gaboto. 
                            </item>
                            
                            <label>schemas</label>
                            <item>
                                Transforms defined ontologies into Java helper classes (see <ptr target="#transformOntologyIntoJava"/>). 
                            </item>
                        </list>
                    </p>
                </div>
            </div>
            
            <div xml:id="chap_extending_transformations">
                <head>Output Transformation</head>
                <p>
                    Gaboto allows for the dynamic transformation of GabotoEntityPools into specified
                    output formats. These transformations are independent from the entities inside
                    the pool. In this section we'll have a look at existing transformers, their
                    implementations and how to create new transformers.
                </p>
                
                <div>
                    <head>General Approach</head>
                    <p>
                        Basically, there are two approaches to writing a transformer. The first approach
                        is to transform entire entities including all their properties into an output format
                        that can then be processed by another system. The <hi>JSON transformer</hi> does exactly
                        that and transforms entire entities into a JSON representation that can then be easily
                        processed from within JavaScript or in any other system that allows to import
                        JSON.
                    </p>
                    <p>
                        The <hi>KML transformer</hi> follows a different approach. It looks for few very specific
                        properties that it needs to create valid KML documents and thereby ignores most of an entity's
                        properties. It also adds specific KML transformation properties, that an entity might
                        "implement" to guide the KML transformation process.
                    </p>
                </div>
                
                <div>
                    <head>The KML Transformer</head>
                    <p>
                        In its simplest form the KML transformer looks for three properties:
                        <list type="bulleted">
                            <item>&dc;title</item>
                            <item>&dc;description</item>
                            <item>&oxp;hasLocation</item>
                        </list>
                        It uses the generic methods provided by the <ref target="#chap_objectModel_GabotoEntity">GabotoEntity</ref>
                        object (<emph>getPropertyValue</emph>) to see whether the entity that it currently transforms
                        has these properties or not. 
                    </p>
                    <p>
                        A simple transformation of two entities from OxPoints could produce this KML:
                        <eg>
    &lt;kml xmlns=&quot;http://www.opengis.net/kml/2.2&quot;&gt;
        &lt;Document&gt;
            &lt;Placemark&gt;
                &lt;name&gt;All Souls College&lt;/name&gt;
                &lt;description&gt;&lt;![CDATA[Website: &lt;a href=&quot;http://www.all-souls.ox.ac.uk&quot;&gt;http://www.all-souls.ox.ac.uk&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;http://www.oucs.ox.ac.uk/oxpoints/images/collegepictures/alls.jpg&quot; width=&quot;167px&quot; height=&quot;125px&quot;/&gt;]]&gt;&lt;/description&gt;
                &lt;Point&gt;
                    &lt;coordinates&gt;-1.253042221069336,51.75278555467572&lt;/coordinates&gt;
                &lt;/Point&gt;
            &lt;/Placemark&gt;
            &lt;Placemark&gt;
                &lt;name&gt;Computing Services&lt;/name&gt;
                &lt;description&gt;&lt;![CDATA[Website: &lt;a href=&quot;http://www.oucs.ox.ac.uk/&quot;&gt;http://www.oucs.ox.ac.uk/&lt;/a&gt;&lt;br/&gt;]]&gt;&lt;/description&gt;
                &lt;Point&gt;
                    
                    &lt;coordinates&gt;-1.26035,51.76001&lt;/coordinates&gt;
                &lt;/Point&gt;
            &lt;/Placemark&gt;
        &lt;/Document&gt;
    &lt;/kml&gt;

                        </eg>
                    </p>
                    <p>
                        Besides the properties mentioned above, the KML transformer also looks for a property
                        specific to its KML transformation: <hi>&gabotoKML;parent</hi>. When constructing the 
                        name of a placemark the KML transformer tries to establish a hierarchy using the <hi>parent</hi>
                        property in order to add the names of all direct ancestors to the KML <gi>name</gi> element.
                    </p>
                    <p>
                        Since this property is seldom something an entity actually stores under this name, it is
                        usually modelled using an <hi>unstored property</hi> (see <ptr target="#porperties_unstoredProperty"/>).
                        For example, the All Souls College Library is a subunit of All Souls College
                        <eg>
    &lt;kml xmlns=&quot;http://www.opengis.net/kml/2.2&quot;&gt;
        &lt;Document&gt;
            &lt;Placemark&gt;
                &lt;name&gt;All Souls College Library, All Souls College&lt;/name&gt;
                &lt;description&gt;&lt;![CDATA[Website: &lt;a href=&quot;http://www.all-souls.ox.ac.uk/library/&quot;&gt;http://www.all-souls.ox.ac.uk/library/&lt;/a&gt;&lt;br/&gt;]]&gt;&lt;/description&gt;
                &lt;Point&gt;
                    &lt;coordinates&gt;-1.253042221069336,51.75278555467572&lt;/coordinates&gt;
                &lt;/Point&gt;
            &lt;/Placemark&gt;
        &lt;/Document&gt;
    &lt;/kml&gt;
                        </eg>
                    </p>
                </div>
                
                <div>
                    <head>The JSON Transformer</head>
                    <p>
                        The JSON transformer follows a very different approach. It does not care about specific
                        properties an entity might have or might not have, but it transforms all properties an entity
                        has. For this, it also uses the generic methods made available by the <ref target="#chap_objectModel_GabotoEntity">GabotoEntity</ref>
                        object (<emph>getAllDirectProperties</emph>, <emph>getAllPassiveProperties</emph> and
                        <emph>getAllIndirectProperties</emph>). All properties are transformed into JSON key value
                        pairs. If the value is another entity, a sub object is created and depending on the configured
                        nesting level all of its properties are added.
                    </p>
                    <p>
                        This is the JSON output for <hi>All Souls College Library</hi> with a nesting level of 1 (this
                        means that the properties of directly referenced entities are not included in the output):
                        <eg>
                <![CDATA[
    [{"uri":"http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/451091d3",
      "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Library",
      "http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#hasOUCSCode":"O_lib_asc",
      "http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#subsetOf":{
         "uri":"http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/eacfd81c",
         "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#College",
         "nestingToDeep":true
      }
      "http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#hasITHomepage":null,
      "http://purl.org/dc/elements/1.1/description":"Website: <a href=\"http://www.all-souls.ox.ac.uk/library/\">http://www.all-souls.ox.ac.uk/library/<\/a><br/>",
      "http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#hasHomepage":{
    	 "uri":"http://www.all-souls.ox.ac.uk/library/",
    	 "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Website",
    	 "nestingToDeep":true
      },
      "http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#hasLibraryHomepage":{
      	 "uri":"http://www.lib.ox.ac.uk/libraries/guides/ASC.html",
      	 "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Website",
      	 "nestingToDeep":true
      },
      "http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#hasWeblearn":null,
      "http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#occupies":null,
      "http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#primaryPlace":null,
      "http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#hasOLISCode":"ASC",
      "http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#inImage":null,
      "http://ns.ox.ac.uk/namespace/gaboto/kml/2009/03/owl#parent":{
      	 "uri":"http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/eacfd81c",
      	 "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#College",
      	 "nestingToDeep":true
      },
      "http://purl.org/dc/elements/1.1/title":"All Souls College Library",
      "http://nwalsh.com/rdf/vCard#adr":null,
      "http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#hasLocation":{
      	 "http://www.opengis.net/gml/pos":"-1.253042221069336 51.75278555467572"
      },
      "passiveProperties":{
      	 "http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#subsetOf":[
      		{ "uri":"http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/9152267c",
      		  "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Library",
      		  "nestingToDeep":true},
      		{"uri":"http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/ae209cfc",
      		 "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Library",
      		 "nestingToDeep":true},
      		{"uri":"http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/de0e1221",
      		 "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Library",
      		 "nestingToDeep":true},
      		{"uri":"http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/74c2f3f6",
      		 "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Library",
      		 "nestingToDeep":true},
      		{"uri":"http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/bb83b72f",
      		 "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Library",
      		 "nestingToDeep":true},
      		{"uri":"http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/dca87473", 
      		 "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Library",
      		 "nestingToDeep":true},
      		{"uri":"http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/e64e46e5",
      		 "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Library",
      		 "nestingToDeep":true},
      		{"uri":"http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/95331e00",
      		 "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Library",
      		 "nestingToDeep":true},
      		{"uri":"http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/568a19b6",
      		 "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Library",
      		 "nestingToDeep":true},
      		{"uri":"http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/c4573969",
      		 "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Library",
      		 "nestingToDeep":true},
      		{"uri":"http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/3651f49e",
      		 "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Library",
      		 "nestingToDeep":true},
      		{"uri":"http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/0b80626d",
      		 "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Library",
      		 "nestingToDeep":true},
      		{"uri":"http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/5762f9fd",
      		 "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Library",
      		 "nestingToDeep":true},
      		{"uri":"http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/bd13f56e",
      		 "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Library",
      		 "nestingToDeep":true},
      		{"uri":"http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/2a770d05",
      		 "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Library",
      		 "nestingToDeep":true},
      		{"uri":"http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/139108dc",
      		 "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Library",
      		 "nestingToDeep":true},
      		{"uri":"http://ns.ox.ac.uk/namespaces/oxpoints/data/unit/0c5d61a7",
      		 "type":"http://ns.ox.ac.uk/namespace/oxpoints/2009/02/owl#Library",
      		 "nestingToDeep":true}
      	]
      }
    }]                
                ]]>                            
                        </eg>
                    </p>
                </div>
                
                <div>
                    <head>Adding new Output Transformations to Gaboto</head>
                    <p>
                        New transformers should implement the <hi>EntityPoolTransformer</hi> interface.
                    </p>
                </div>
            </div>
            
            <div>
                <head>Insights into Gaboto</head>
                <p>
                    In this section I want to explain some of the ideas behind Gaboto's implementation.
                </p>
                <div>
                    <head>JavaBeans vs. GabotoEntity and GabotoBean</head>
                    <p>
                        Java Beans are reusable software components that follow certain coding guidelines and
                        allow introspection (accessing information about themselve at runtime). GabotoEntities
                        and Beans follow the Java Bean coding guidelines, but introspection is handled differently.
                    </p>
                    <p>
                        As described in <ptr target="#chap_configuring_properties"/>, Gaboto knows of a range
                        of different property types, that have to be treated differently when trying to retrieve
                        or store values. For example an indirect property follows a path to a different GabotoEntity
                        and searches for the property in question there. In order to differentiate between the
                        different properties, Gaboto makes use of <ref target="http://en.wikipedia.org/wiki/Java_annotation">Java annotations</ref>.
                    </p>
                    <p>
                        Java annotations allow us to tag classes, methods and fields with defined annotations
                        that can be accessed at runtime. This technique is called 
                        <ref target="http://java.sun.com/docs/books/tutorial/reflect/index.html">reflection</ref>.
                        Through the java reflection API, we can now, for example, loop over the methods of an
                        object, and test each method for present annotations. 
                    </p>
                    <div>
                        <head>Gaboto's Annotation</head>
                        <p>
                            In GabotoEntities and GabotoBeans methods are annotated to describe the 
                            sort of property this method represents. GabotoBeans can only have
                            direct properties.
                        </p>
                        
                        <div>
                            <head>Direct Properties</head>
                            <p>
                                Direct properties are properties that are stored together with the
                                entity/bean or that can be directly retrieved from the entity/bean.
                            </p>
                        
                            <div>
                                <head>Direct Stored Properties</head>
                                <p>
                                    Properties that are stored together with the entity/bean.
                                </p>
                                
                                <div>
                                    <head>SimpleLiteralProperty</head>
                                </div>
                                <div>
                                    <head>SimpleURIProperty</head>
                                </div>
                                <div>
                                    <head>ComplexProperty</head>
                                </div>
                                <div>
                                    <head>BagLiteralProperty</head>
                                </div>
                                <div>
                                    <head>BagURIProperty</head>
                                </div>
                                <div>
                                    <head>BagComplexProperty</head>
                                </div>
                            </div>
                            
                            <div>
                                <head>Direct Unstored Properties</head>
                                <p>
                                    Properties that are not stored, but that can be retrieved directly
                                    from the entity/bean.
                                </p>
                                <div>
                                    <head>StaticProperty</head>
                                </div>
                                    
                                <div>
                                    <head>UnstoredProperty</head>
                                </div>
                            </div>
                            
                        </div>
                        
                        <div>
                            <head>IndirectProperty</head>
                            <p>
                                Indirect properties are properties that are not stored directly with an
                                entity, but with an entity that can be referenced (not necessarily directly)
                                from this entity.
                            </p>
                        </div>
                        <div>
                            <head>PassiveProperty</head>
                        </div>
                    </div>
                </div>
            </div>
            
            <div>
                <head>To Do</head>
                <p>
                    Here are a list of ideas of how Gaboto might be further improved.
                </p>
                
                <div>
                    <head>Multiple Inheritance</head>
                    <p>
                        RDF supports multiple inheritance. To map this to java, Gaboto needs to create interfaces
                        and interface implementations from the configuration file rather than just the implementations.
                    </p>
                </div>
                <div>
                    <head>Get rid of Reflection when creating RDF from a GabotoPool/GabotoEntity</head>
                    <p>
                        This would increase the speed of adding data to the system and of generating
                        RDF output.
                    </p>
                    <p>
                        To achieve this, specialized methods (similar to <emph>loadFromSnapshot</emph>) need to be created during the configuration
                        process. The <emph>getTriplesFor</emph> method of the GabotoEntity object has then to be 
                        changed to use the dynamically created method instead of the reflection object (<emph>RDFContainerTripleGeneratorImpl</emph>). 
                    </p>
                </div>
                <div>
                    <head>More simple Datatypes</head>
                    <p>
                        As Jena offers the full range of XSD datatypes, Gaboto should support more than the currently
                        supported primitive java types for literal properties.
                    </p>
                </div>
                <div>
                    <head>Make GabotoQuery know about existing Transformations</head>
                    <p>
                        Currently GabotoQueryImpl only knows about the already existing transformations.
                        It should be possible to make it aware of newly available transformations.
                    </p>
                </div>
                <div>
                    <head>Add new Import Mechanisms (e.g., JSON Importer)</head>
                    <p>
                        JSON could easily be used to add data into the system. In order to achieve
                        this a JSON to GabotoEntity converter had to be written.
                    </p>
                </div>
                <div>
                    <head>Create option to leave out Time Dimension</head>
                    <p>
                        In many projects the Time Dimension might not be necessary. It should be easy
                        for these projects to get rid of the time dimension and not having to create
                        the same snapshot all the time.
                    </p>
                </div>
                <div>
                    <head>Remove Custom Methods from Config File</head>
                    <p>
                        It would be nicer to be able to create custom methods for entities/beans directly
                        in your IDE instead of in the XML configuration file. For this each entity/bean
                        needs to consist of a super and a subclass. The super class is the one that is
                        generated from the configuration, while the subclass is the one that is actually
                        used by the user. Here the user can easily add custom methods.
                    </p>
                </div>
                <div>
                    <head>Allow for specific Jena Database configuration</head>
                    <p>
                        Jena offers a couple of configuration properties for persistent models
                        (see <ptr target="http://jena.sourceforge.net/DB/creating-db-models.html"/>). It would
                        be nice if these could be configured from within the Gaboto configuration file.
                    </p>
                </div>
            </div>
        </div>
      </body>
      <back>
          <div xml:id="configuration_schema">
              <head>Configuration File Schema</head>
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
<xi:include href="../schemas/Gaboto.xsd" />              
              </egXML>
          </div>
      </back>
  </text>
</TEI>
